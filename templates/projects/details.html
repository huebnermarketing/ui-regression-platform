<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ project.name }} - PixelPulse</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        /* Modern Color Palette */
        :root {
            --primary-text: #0F172A;
            --accent-color: #3b82f6;
            --background: #FEFEFE;
            --subtle-text: #8E9093;
            --sidebar-bg: #0F172A;
            --border-color: #BFCDD6;
            --card-bg: #f5f7fa;
            --success-color: #10b981;
            --warning-color: #f59e0b;
            --danger-color: #ef4444;
            --info-color: #3b82f6;
            --card-shadow: 0 4px 6px -1px rgba(15, 23, 42, 0.1), 0 2px 4px -1px rgba(15, 23, 42, 0.06);
            --card-shadow-hover: 0 10px 15px -3px rgba(15, 23, 42, 0.1), 0 4px 6px -2px rgba(15, 23, 42, 0.05);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--background);
            color: var(--primary-text);
            overflow-x: hidden;
        }

        /* Sidebar Navigation */
        .sidebar {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            width: 280px;
            background: var(--sidebar-bg);
            border-right: 1px solid rgba(191, 205, 214, 0.2);
            z-index: 1000;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }

        .sidebar-header {
            padding: 1.5rem;
            border-bottom: 1px solid rgba(191, 205, 214, 0.2);
        }

        .sidebar-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            text-decoration: none;
            color: #FEFEFE;
        }

        .sidebar-logo-icon {
            width: 40px;
            height: 40px;
            background: var(--accent-color);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.25rem;
        }

        .sidebar-logo-text {
            font-size: 1.25rem;
            font-weight: 700;
            color: #FEFEFE;
        }

        .sidebar-user {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid rgba(191, 205, 214, 0.2);
        }

        .user-info {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .user-avatar {
            width: 40px;
            height: 40px;
            background: var(--accent-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }

        .user-details h6 {
            margin: 0;
            font-size: 0.875rem;
            font-weight: 600;
            color: #FEFEFE;
        }

        .user-details p {
            margin: 0;
            font-size: 0.75rem;
            color: #8E9093;
        }

        .sidebar-nav {
            padding: 1rem 0;
        }

        .nav-item {
            margin: 0.25rem 1rem;
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            color: #BFCDD6;
            text-decoration: none;
            border-radius: 8px;
            transition: all 0.2s ease;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .nav-link:hover {
            background: rgba(59, 130, 246, 0.1);
            color: #FEFEFE;
        }

        .nav-link.active {
            background: var(--accent-color);
            color: white;
        }

        .nav-link i {
            width: 20px;
            text-align: center;
        }

        /* Main Content */
        .main-content {
            margin-left: 280px;
            min-height: 100vh;
            background: var(--card-bg);
        }

        /* Top Bar */
        .top-bar {
            background: var(--background);
            border-bottom: 1px solid var(--border-color);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .page-header h1 {
            font-size: 1.5rem;
            font-weight: 700;
            margin: 0;
            color: var(--primary-text);
        }

        .page-header p {
            margin: 0;
            color: var(--subtle-text);
            font-size: 0.875rem;
        }

        .page-meta {
            font-size: 0.75rem;
            color: var(--subtle-text);
            margin-top: 0.25rem;
        }

        .btn-action {
            background: var(--accent-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            text-decoration: none;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-action:hover {
            background: #2563eb;
            color: white;
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: var(--card-bg);
            color: var(--primary-text);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--border-color);
            color: var(--primary-text);
        }

        .btn-danger {
            background: var(--danger-color);
            color: white;
            border: none;
        }

        .btn-danger:hover {
            background: #dc2626;
            color: white;
        }

        /* Content Area */
        .content-area {
            padding: 2rem;
        }

        /* Cards */
        .info-card {
            background: var(--background);
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
            margin-bottom: 1.5rem;
        }

        .info-card-header {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--card-bg);
            border-radius: 12px 12px 0 0;
        }

        .info-card-title {
            font-size: 0.875rem;
            font-weight: 600;
            margin: 0;
            color: var(--primary-text);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .info-card-body {
            padding: 1rem 1.5rem;
        }

        .url-link {
            color: var(--accent-color);
            text-decoration: none;
            word-break: break-all;
        }

        .url-link:hover {
            color: #2563eb;
            text-decoration: underline;
        }

        /* Crawl Status Card */
        .crawl-status-card {
            background: var(--background);
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
            border-left: 4px solid var(--accent-color);
            margin-bottom: 2rem;
        }

        .crawl-status-body {
            padding: 1.5rem;
        }

        .status-badge {
            padding: 0.375rem 0.75rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .status-badge.warning {
            background: rgba(245, 158, 11, 0.1);
            color: var(--warning-color);
        }

        .status-badge.success {
            background: rgba(16, 185, 129, 0.1);
            color: var(--success-color);
        }

        .status-badge.secondary {
            background: rgba(142, 144, 147, 0.1);
            color: var(--subtle-text);
        }

        .progress-container {
            margin-top: 1rem;
        }

        .progress {
            height: 8px;
            border-radius: 4px;
            background: var(--card-bg);
        }

        .progress-bar {
            border-radius: 4px;
        }

        /* Filter Section */
        .filter-card {
            background: var(--background);
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .form-control, .form-select {
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            transition: all 0.2s ease;
            background: var(--background);
            color: var(--primary-text);
        }

        .form-control:focus, .form-select:focus {
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .form-label {
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--primary-text);
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Table */
        .table-card {
            background: var(--background);
            border-radius: 12px;
            box-shadow: var(--card-shadow);
            border: 1px solid var(--border-color);
            overflow: hidden;
        }

        .table-card-header {
            padding: 1.5rem;
            border-bottom: 1px solid var(--border-color);
            background: var(--card-bg);
        }

        .table-card-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin: 0;
            color: var(--primary-text);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .table-card-body {
            padding: 0;
        }

        .modern-table {
            margin: 0;
            border-collapse: separate;
            border-spacing: 0;
        }

        .modern-table thead th {
            background-color: var(--card-bg);
            border: none;
            border-bottom: 2px solid var(--border-color);
            padding: 1rem 1.5rem;
            font-weight: 600;
            font-size: 0.875rem;
            color: var(--primary-text);
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }

        .modern-table tbody tr {
            border-bottom: 1px solid #f1f5f9;
            transition: all 0.2s ease;
        }

        .modern-table tbody tr:hover {
            background-color: var(--card-bg);
        }

        .modern-table tbody td {
            padding: 1rem 1.5rem;
            border: none;
            vertical-align: middle;
        }

        .page-breadcrumb {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .page-title {
            font-weight: 600;
            font-size: 0.875rem;
            color: var(--primary-text);
        }

        .page-path {
            font-size: 0.75rem;
        }

        .page-path code {
            background: var(--card-bg);
            color: var(--subtle-text);
            padding: 0.125rem 0.25rem;
            border-radius: 3px;
            font-size: 0.75rem;
            border: 1px solid var(--border-color);
        }

        .url-cell {
            max-width: 250px;
            word-break: break-all;
        }

        .breadcrumb-cell {
            max-width: 300px;
            min-width: 200px;
        }

        .pagination-info {
            color: var(--subtle-text);
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }

        /* Empty State */
        .empty-state {
            text-align: center;
            padding: 4rem 2rem;
        }

        .empty-icon {
            font-size: 4rem;
            color: var(--subtle-text);
            margin-bottom: 1rem;
        }

        .empty-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--primary-text);
        }

        .empty-description {
            color: var(--subtle-text);
            margin-bottom: 2rem;
        }

        /* Modal */
        .modal-content {
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .modal-header {
            border-bottom: 1px solid var(--border-color);
            background: var(--card-bg);
        }

        .modal-title {
            color: var(--primary-text);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .sidebar {
                transform: translateX(-100%);
            }

            .sidebar.open {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
            }

            .top-bar {
                padding: 1rem;
            }

            .content-area {
                padding: 1rem;
            }

            .modern-table thead th,
            .modern-table tbody td {
                padding: 0.75rem 1rem;
            }
        }

        .mobile-menu-btn {
            display: none;
            background: none;
            border: none;
            font-size: 1.25rem;
            color: var(--primary-text);
            padding: 0.5rem;
        }

        @media (max-width: 768px) {
            .mobile-menu-btn {
                display: block;
            }
        }

        /* Additional styles for multi-viewport UI */
        .btn-xs {
            padding: 0.125rem 0.25rem;
            font-size: 0.75rem;
            line-height: 1.2;
            border-radius: 0.2rem;
        }

        .form-check {
            margin-bottom: 0.5rem;
        }

        .form-check-label {
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .manual-capture-section {
            background: var(--background);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        /* Visual Diff Viewer Styles */
        .diff-thumbnail-card {
            background: var(--background);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            transition: all 0.2s ease;
        }

        .diff-thumbnail-card:hover {
            box-shadow: var(--card-shadow-hover);
            transform: translateY(-2px);
        }

        .diff-thumbnail-header {
            background: var(--card-bg);
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border-color);
        }

        .diff-thumbnail-body {
            position: relative;
            padding: 1rem;
            text-align: center;
        }

        .diff-thumbnail-img {
            max-height: 300px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }

        .diff-thumbnail-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: all 0.2s ease;
        }

        .diff-thumbnail-body:hover .diff-thumbnail-overlay {
            opacity: 1;
        }

        .diff-thumbnail-body:hover .diff-thumbnail-img {
            filter: brightness(0.7);
        }

        .viewport-icon {
            width: 40px;
            height: 40px;
            background: var(--accent-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 1.2rem;
            margin: 0 auto 0.25rem;
        }

        .diff-percentage .badge {
            font-size: 0.875rem;
            padding: 0.375rem 0.75rem;
        }

        /* Accordion Styles for History */
        .history-accordion .accordion-item {
            border: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
            border-radius: 8px;
            overflow: hidden;
        }

        .history-accordion .accordion-header {
            background: var(--card-bg);
        }

        .history-accordion .accordion-button {
            background: var(--card-bg);
            color: var(--primary-text);
            border: none;
            padding: 1rem 1.5rem;
            font-weight: 600;
        }

        .history-accordion .accordion-button:not(.collapsed) {
            background: var(--accent-color);
            color: white;
            box-shadow: none;
        }

        .history-accordion .accordion-button:focus {
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }

        .history-accordion .accordion-body {
            padding: 0;
        }

        .viewport-buttons {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            background: var(--background);
            border-top: 1px solid var(--border-color);
        }

        .viewport-btn {
            width: 50px;
            height: 50px;
            border: 2px solid var(--border-color);
            background: var(--background);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .viewport-btn:hover {
            border-color: var(--accent-color);
            background: rgba(59, 130, 246, 0.1);
            transform: translateY(-2px);
        }

        .viewport-btn i {
            font-size: 1.2rem;
            color: var(--primary-text);
        }

        .viewport-btn .viewport-label {
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: var(--subtle-text);
            white-space: nowrap;
        }

        .viewport-btn .diff-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            font-size: 0.625rem;
            padding: 0.125rem 0.25rem;
            border-radius: 10px;
        }

        .page-info {
            padding: 1rem 1.5rem;
            background: var(--background);
            border-bottom: 1px solid var(--border-color);
        }

        .page-title-large {
            font-size: 1rem;
            font-weight: 600;
            color: var(--primary-text);
            margin-bottom: 0.25rem;
        }

        .page-path-large {
            font-size: 0.875rem;
            color: var(--subtle-text);
            font-family: 'Courier New', monospace;
        }

        .page-stats {
            display: flex;
            gap: 1rem;
            align-items: center;
            margin-top: 0.5rem;
        }

        .page-stat {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            font-size: 0.75rem;
            color: var(--subtle-text);
        }

        /* Inline Viewport Icons */
        .viewport-icons-inline {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-left: 1rem;
        }

        .viewport-icon-inline {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0.25rem;
            border-radius: 4px;
            transition: all 0.2s ease;
            min-width: 40px;
        }

        .viewport-icon-inline.clickable:hover {
            background: rgba(59, 130, 246, 0.1);
            transform: translateY(-1px);
        }

        .viewport-icon-inline.disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .viewport-emoji {
            font-size: 1.2rem;
            margin-bottom: 0.125rem;
        }

        .diff-badge-inline {
            font-size: 0.625rem;
            padding: 0.125rem 0.25rem;
            border-radius: 8px;
            min-width: 28px;
            text-align: center;
        }

        .page-info-header {
            flex: 1;
        }

        .page-details {
            padding: 1rem 1.5rem;
        }

        .page-meta {
            margin-top: 0.5rem;
            font-size: 0.75rem;
        }

        /* Prevent accordion button from triggering when clicking viewport icons */
        .viewport-icons-inline {
            pointer-events: auto;
        }

        .viewport-icon-inline.clickable {
            pointer-events: auto;
        }

        .accordion-button {
            pointer-events: auto;
        }

        .viewport-icons-inline .viewport-icon-inline {
            z-index: 10;
            position: relative;
        }

        /* History page item styling */
        .history-page-item {
            background: var(--background);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 0.25rem;
            transition: all 0.2s ease;
        }

        .history-page-item:hover {
            box-shadow: var(--card-shadow-hover);
            transform: translateY(-1px);
        }

        /* Compact styling for history items */
        .page-title-compact {
            line-height: 1.2;
        }

        .page-path-compact {
            line-height: 1.1;
        }

        .page-link-compact:hover {
            text-decoration: underline !important;
        }

        /* Enhanced Visual Diff Modal Styles */
        .diff-section-header {
            background: var(--card-bg) !important;
            border-bottom: 1px solid var(--border-color) !important;
        }

        .diff-section-body {
            position: relative;
            min-height: 400px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .diff-section-img {
            transition: all 0.2s ease;
            cursor: zoom-in;
        }

        .diff-section-body:hover .diff-section-img {
            filter: brightness(0.9);
        }

        .diff-section-body:hover .diff-section-overlay {
            opacity: 1 !important;
        }

        .viewport-icon-small {
            width: 24px;
            height: 24px;
            background: var(--accent-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.75rem;
        }

        .modal-footer {
            border-top: 1px solid var(--border-color);
            background: var(--card-bg) !important;
        }

        /* Image fallback styles */
        .image-fallback {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 300px;
            background-color: #f8f9fa;
            border: 2px dashed #dee2e6;
            color: #6c757d;
            font-size: 14px;
            text-align: center;
            border-radius: 4px;
            margin: 1rem;
        }
    </style>
</head>
<body>
    <!-- Sidebar Navigation -->
    <div class="sidebar" id="sidebar">
        <!-- Sidebar Header -->
        <div class="sidebar-header">
            <a href="{{ url_for('dashboard') }}" class="sidebar-logo">
                <div class="sidebar-logo-icon">
                    <i class="fas fa-chart-line"></i>
                </div>
                <div class="sidebar-logo-text">PixelPulse</div>
            </a>
        </div>

        <!-- User Profile -->
        <div class="sidebar-user">
            <div class="user-info">
                <div class="user-avatar">
                    {{ current_user.username[0].upper() }}
                </div>
                <div class="user-details">
                    <h6>{{ current_user.username }}</h6>
                    <p>Administrator</p>
                </div>
            </div>
        </div>

        <!-- Navigation Menu -->
        <nav class="sidebar-nav">
            <div class="nav-item">
                <a href="{{ url_for('dashboard') }}" class="nav-link">
                    <i class="fas fa-home"></i>
                    <span>Dashboard</span>
                </a>
            </div>
            <div class="nav-item">
                <a href="{{ url_for('projects_list') }}" class="nav-link active">
                    <i class="fas fa-folder"></i>
                    <span>Projects</span>
                </a>
            </div>
            <div class="nav-item">
                <a href="{{ url_for('analytics_dashboard') }}" class="nav-link">
                    <i class="fas fa-chart-bar"></i>
                    <span>Analytics</span>
                </a>
            </div>
            <div class="nav-item">
                <a href="#" class="nav-link">
                    <i class="fas fa-bell"></i>
                    <span>Alerts</span>
                </a>
            </div>
            <div class="nav-item">
                <a href="#" class="nav-link">
                    <i class="fas fa-file-alt"></i>
                    <span>Reports</span>
                </a>
            </div>
            <div class="nav-item">
                <a href="#" class="nav-link">
                    <i class="fas fa-code"></i>
                    <span>API Access</span>
                </a>
            </div>
            <div class="nav-item">
                <a href="{{ url_for('settings.settings_page') }}" class="nav-link">
                    <i class="fas fa-cog"></i>
                    <span>Settings</span>
                </a>
            </div>
        </nav>
    </div>

    <!-- Main Content -->
    <div class="main-content">
        <!-- Top Bar -->
        <div class="top-bar">
            <div class="page-header">
                <button class="mobile-menu-btn" onclick="toggleSidebar()">
                    <i class="fas fa-bars"></i>
                </button>
                <h1>{{ project.name }}</h1>
                <p>Project Details & Page Management</p>
                <div class="page-meta">
                    <i class="fas fa-calendar"></i>
                    Created {{ project.created_at|ist_datetime }}
                </div>
            </div>
            <div class="d-flex gap-2">
                <a href="{{ url_for('projects_list') }}" class="btn-action btn-secondary">
                    <i class="fas fa-arrow-left"></i>
                    Back to Projects
                </a>
                <button type="button" class="btn-action btn-danger" data-bs-toggle="modal" data-bs-target="#deleteModal">
                    <i class="fas fa-trash"></i>
                    Delete
                </button>
            </div>
        </div>

        <!-- Content Area -->
        <div class="content-area">
            <!-- Flash Messages -->
            {% with messages = get_flashed_messages(with_categories=true) %}
                {% if messages %}
                    {% for category, message in messages %}
                        <div class="alert alert-{{ 'danger' if category == 'error' else 'success' if category == 'success' else 'info' }} alert-dismissible fade show" role="alert">
                            {{ message }}
                            <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                        </div>
                    {% endfor %}
                {% endif %}
            {% endwith %}

            <!-- Project Info Cards -->
            <div class="row mb-4">
                <div class="col-md-6">
                    <div class="info-card">
                        <div class="info-card-header">
                            <h6 class="info-card-title">
                                <i class="fas fa-globe"></i>
                                Staging Environment
                            </h6>
                        </div>
                        <div class="info-card-body">
                            <a href="{{ project.staging_url }}" target="_blank" class="url-link">
                                {{ project.staging_url }}
                                <i class="fas fa-external-link-alt ms-1"></i>
                            </a>
                        </div>
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="info-card">
                        <div class="info-card-header">
                            <h6 class="info-card-title">
                                <i class="fas fa-globe"></i>
                                Production Environment
                            </h6>
                        </div>
                        <div class="info-card-body">
                            <a href="{{ project.production_url }}" target="_blank" class="url-link">
                                {{ project.production_url }}
                                <i class="fas fa-external-link-alt ms-1"></i>
                            </a>
                        </div>
                    </div>
                </div>
            </div>


            <!-- Jobs History Section -->
            <div class="table-card mt-4">
                <div class="table-card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <h5 class="table-card-title">
                            <i class="fas fa-clock"></i>Jobs History
                        </h5>
                        <button type="button" class="btn-action" id="startJobBtn" style="background: var(--success-color);">
                            <i class="fas fa-play-circle"></i>Start Job
                        </button>
                    </div>
                </div>
                <div class="table-card-body">
                    <div class="table-responsive">
                        <table class="table modern-table" id="jobsHistoryTable">
                            <thead>
                                <tr>
                                    <th style="width: 100px;">JOB ID</th>
                                    <th style="width: 180px;">UPDATED AT</th>
                                    <th style="width: 150px;">STATUS</th>
                                    <th style="width: 100px;">PAGES</th>
                                    <th style="width: 120px;">ACTION</th>
                                </tr>
                            </thead>
                            <tbody id="jobsHistoryTableBody">
                                <!-- Jobs will be populated here -->
                            </tbody>
                        </table>
                    </div>
                    
                    <!-- Empty State for Jobs History -->
                    <div class="empty-state" id="jobsHistoryEmpty" style="display: none;">
                        <div class="empty-icon">
                            <i class="fas fa-clock"></i>
                        </div>
                        <h3 class="empty-title">No Jobs History</h3>
                        <p class="empty-description">
                            No crawling jobs have been started yet. Click "Start Job" to begin your first crawling job.
                        </p>
                    </div>
                </div>
            </div>

            <!-- Add horizontal spacing between Job History and Discovered Pages -->
            <div style="margin-top: 3rem;"></div>

            <!-- Discovered Pages Table -->
            <div class="table-card" id="discovered-pages-section">
                <div class="table-card-header">
                    <div class="d-flex justify-content-between align-items-center">
                        <div>
                            <h5 class="table-card-title">
                                <i class="fas fa-list-ul"></i>Discovered Pages
                                {% if pagination %}
                                    <span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);">{{ pagination.total }}</span>
                                {% elif pages %}
                                    <span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);">{{ pages|length }}</span>
                                {% else %}
                                    <span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);">0</span>
                                {% endif %}
                            </h5>
                            {% if pagination %}
                                <div class="pagination-info" style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--subtle-text);">
                                    Showing {{ ((pagination.page - 1) * pagination.per_page) + 1 }} to {{ pagination.page * pagination.per_page if pagination.page * pagination.per_page < pagination.total else pagination.total }} of {{ pagination.total }} pages
                                </div>
                            {% elif pages %}
                                <div class="pagination-info" style="margin-top: 0.5rem; font-size: 0.875rem; color: var(--subtle-text);">
                                    Showing 1 to {{ pages|length }} of {{ pages|length }} pages
                                </div>
                            {% endif %}
                        </div>
                        
                        <!-- Filters and Controls on the Right -->
                        <div class="d-flex align-items-center gap-3">
                            <!-- Find Difference Button -->
                            {% if pages %}
                                <form id="findDifferenceForm" method="POST" action="{{ url_for('find_difference', project_id=project.id) }}" class="d-inline">
                                    <button type="submit" id="findDifferenceBtn" class="btn-action" style="background: #9333ea;">
                                        <i class="fas fa-search-plus"></i>Find Difference
                                    </button>
                                </form>
                            {% endif %}
                            
                            <!-- Search Pages -->
                            <div class="d-flex align-items-center gap-2">
                                <i class="fas fa-search text-muted"></i>
                                <input type="text" class="form-control form-control-sm" id="pageSearch" placeholder="Search by path, title, or URL..." style="width: 250px;">
                            </div>
                            
                            <!-- Filter by Status -->
                            <div class="d-flex align-items-center gap-2">
                                <i class="fas fa-filter text-muted"></i>
                                <select class="form-select form-select-sm" id="statusFilter" style="width: 150px;">
                                    <option value="">All Statuses</option>
                                    <option value="completed">Completed</option>
                                    <option value="no_baseline">No Baseline</option>
                                    <option value="failed">Failed</option>
                                    <option value="not_started">Not Started</option>
                                </select>
                            </div>
                            
                            <!-- Per Page -->
                            <div class="d-flex align-items-center gap-2">
                                <span class="text-muted small">Per Page</span>
                                <select class="form-select form-select-sm" id="perPageFilter" style="width: 80px;">
                                    <option value="10">10</option>
                                    <option value="20">20</option>
                                    <option value="50">50</option>
                                    <option value="100">100</option>
                                </select>
                            </div>
                            
                            <!-- Apply/Clear Buttons -->
                            <div class="d-flex gap-2">
                                <button type="button" class="btn btn-primary btn-sm" id="applyFilters">
                                    <i class="fas fa-check"></i>
                                    Apply Filters
                                </button>
                                <button type="button" class="btn btn-outline-secondary btn-sm" id="clearFilters">
                                    <i class="fas fa-times"></i>
                                    Clear
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="table-card-body">
                    {% if pages %}
                        <div class="table-responsive">
                            <table class="table modern-table">
                                <thead>
                                    <tr>
                                        <th style="width: 50px;">
                                            <input type="checkbox" id="selectAllPages" class="form-check-input" title="Select all pages">
                                        </th>
                                        <th>PAGE</th>
                                        <th style="width: 250px;">STAGING URL</th>
                                        <th style="width: 250px;">PRODUCTION URL</th>
                                        <th style="width: 200px;">DIFFERENCE STATUS</th>
                                        <th style="width: 120px;">DURATION</th>
                                        <th style="width: 180px;">LAST RUN</th>
                                        <th style="width: 200px;">RESULTS</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    {% for page in pages %}
                                        <tr>
                                            <td class="text-center">
                                                <input type="checkbox" name="selected_pages" value="{{ page.id }}" class="form-check-input page-checkbox" data-page-id="{{ page.id }}">
                                            </td>
                                            <td class="breadcrumb-cell">
                                                <div class="page-breadcrumb">
                                                    <div class="page-title">{{ page.page_name or page.path or 'Untitled Page' }}</div>
                                                    <div class="page-path">
                                                        <code>{{ page.path or '/' }}</code>
                                                    </div>
                                                </div>
                                            </td>
                                            <td class="url-cell">
                                                {% if page.staging_url %}
                                                    <a href="{{ page.staging_url }}" target="_blank" class="url-link">
                                                        {{ page.staging_url }}
                                                        <i class="fas fa-external-link-alt ms-1"></i>
                                                    </a>
                                                {% else %}
                                                    <small class="text-muted">No URL available</small>
                                                {% endif %}
                                            </td>
                                            <td class="url-cell">
                                                {% if page.production_url %}
                                                    <a href="{{ page.production_url }}" target="_blank" class="url-link">
                                                        {{ page.production_url }}
                                                        <i class="fas fa-external-link-alt ms-1"></i>
                                                    </a>
                                                {% elif project.production_url and page.path %}
                                                    {% set production_full_url = project.production_url.rstrip('/') + '/' + page.path.lstrip('/') %}
                                                    <a href="{{ production_full_url }}" target="_blank" class="url-link">
                                                        {{ production_full_url }}
                                                        <i class="fas fa-external-link-alt ms-1"></i>
                                                    </a>
                                                {% else %}
                                                    <small class="text-muted">No URL available</small>
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if page.find_diff_status == 'ready' %}
                                                    <span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);">
                                                        <i class="fas fa-check-circle me-1"></i>READY
                                                    </span>
                                                {% elif page.find_diff_status == 'finding_difference' %}
                                                    <span class="status-badge" style="background: rgba(147, 51, 234, 0.1); color: #9333ea;">
                                                        <i class="fas fa-search-plus me-1"></i>FINDING DIFFERENCE
                                                    </span>
                                                {% elif page.diff_status_desktop == 'completed' or page.diff_status_tablet == 'completed' or page.diff_status_mobile == 'completed' %}
                                                    <span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);">
                                                        <i class="fas fa-check-circle me-1"></i>COMPLETED
                                                    </span>
                                                {% elif page.diff_status_desktop == 'no_baseline' or page.diff_status_tablet == 'no_baseline' or page.diff_status_mobile == 'no_baseline' %}
                                                    <span class="status-badge" style="background: rgba(245, 158, 11, 0.1); color: var(--warning-color);">
                                                        <i class="fas fa-exclamation-triangle me-1"></i>NO BASELINE
                                                    </span>
                                                {% elif page.diff_status_desktop == 'failed' or page.diff_status_tablet == 'failed' or page.diff_status_mobile == 'failed' %}
                                                    <span class="status-badge" style="background: rgba(239, 68, 68, 0.1); color: var(--danger-color);">
                                                        <i class="fas fa-times-circle me-1"></i>FAILED
                                                    </span>
                                                {% else %}
                                                    <span class="status-badge secondary">
                                                        <i class="fas fa-minus-circle me-1"></i>NOT STARTED
                                                    </span>
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if page.duration_formatted %}
                                                    <span style="color: var(--primary-text); font-weight: 500; font-family: 'Courier New', monospace;">
                                                        {{ page.duration_formatted }}
                                                    </span>
                                                {% else %}
                                                    <small style="color: var(--subtle-text);">-</small>
                                                {% endif %}
                                            </td>
                                            <td>
                                                {% if page.last_run_at %}
                                                    <div class="d-flex flex-column">
                                                        <small style="color: var(--primary-text); font-weight: 500;">{{ page.last_run_at.strftime('%d/%m/%Y') if page.last_run_at else 'Never' }}</small>
                                                        <small style="color: var(--subtle-text); font-size: 0.75rem;">{{ page.last_run_at.strftime('%I:%M %p') if page.last_run_at else '' }}</small>
                                                    </div>
                                                {% else %}
                                                    <small style="color: var(--subtle-text);">Never</small>
                                                {% endif %}
                                            </td>
                                            <td>
                                                <div class="viewport-icons-inline d-flex gap-1 justify-content-center">
                                                    <!-- Desktop Viewport Icon -->
                                                    {% set desktop_clickable = page.diff_status_desktop == 'completed' %}
                                                    <div class="viewport-icon-inline clickable"
                                                         style="cursor: pointer; display: flex; flex-direction: column; align-items: center; padding: 0.25rem; min-width: 35px;"
                                                         title="Desktop - {{ 'Click to view images' if desktop_clickable else 'Click to view available images' }}"
                                                         data-page-id="{{ page.id }}"
                                                         data-page-name="{{ (page.page_name or page.path or 'Untitled Page')|e }}"
                                                         data-page-path="{{ (page.path or '/')|e }}"
                                                         data-viewport="desktop"
                                                         data-diff-pct="{{ page.diff_mismatch_pct_desktop or 0 }}"
                                                         data-last-crawled="{{ page.last_run_at or '' }}"
                                                         data-status="{{ page.diff_status_desktop or 'not_started' }}">
                                                        <span class="viewport-emoji" style="font-size: 1.1rem; margin-bottom: 0.125rem;"><i class="fas fa-desktop"></i></span>
                                                        <small style="color: {% if page.diff_status_desktop == 'completed' %}{% if page.diff_mismatch_pct_desktop and page.diff_mismatch_pct_desktop > 5 %}var(--danger-color){% elif page.diff_mismatch_pct_desktop and page.diff_mismatch_pct_desktop > 1 %}var(--warning-color){% else %}var(--success-color){% endif %}{% elif page.diff_status_desktop == 'failed' %}var(--danger-color){% elif page.diff_status_desktop == 'no_baseline' %}var(--warning-color){% else %}var(--subtle-text){% endif %}; font-weight: 600; font-size: 0.625rem;">
                                                            {% if page.diff_status_desktop == 'completed' %}
                                                                {% if page.diff_mismatch_pct_desktop is not none %}{{ "%.1f"|format(page.diff_mismatch_pct_desktop) }}%{% else %}0.0%{% endif %}
                                                            {% elif page.diff_status_desktop == 'failed' %}!
                                                            {% elif page.diff_status_desktop == 'no_baseline' %}?
                                                            {% else %}-
                                                            {% endif %}
                                                        </small>
                                                    </div>
                                                    
                                                    <!-- Tablet Viewport Icon -->
                                                    {% set tablet_clickable = page.diff_status_tablet == 'completed' %}
                                                    <div class="viewport-icon-inline clickable"
                                                         style="cursor: pointer; display: flex; flex-direction: column; align-items: center; padding: 0.25rem; min-width: 35px;"
                                                         title="Tablet - {{ 'Click to view images' if tablet_clickable else 'Click to view available images' }}"
                                                         data-page-id="{{ page.id }}"
                                                         data-page-name="{{ (page.page_name or page.path or 'Untitled Page')|e }}"
                                                         data-page-path="{{ (page.path or '/')|e }}"
                                                         data-viewport="tablet"
                                                         data-diff-pct="{{ page.diff_mismatch_pct_tablet or 0 }}"
                                                         data-last-crawled="{{ page.last_run_at or '' }}"
                                                         data-status="{{ page.diff_status_tablet or 'not_started' }}">
                                                        <span class="viewport-emoji" style="font-size: 1.1rem; margin-bottom: 0.125rem;"><i class="fas fa-tablet-alt"></i></span>
                                                        <small style="color: {% if page.diff_status_tablet == 'completed' %}{% if page.diff_mismatch_pct_tablet and page.diff_mismatch_pct_tablet > 5 %}var(--danger-color){% elif page.diff_mismatch_pct_tablet and page.diff_mismatch_pct_tablet > 1 %}var(--warning-color){% else %}var(--success-color){% endif %}{% elif page.diff_status_tablet == 'failed' %}var(--danger-color){% elif page.diff_status_tablet == 'no_baseline' %}var(--warning-color){% else %}var(--subtle-text){% endif %}; font-weight: 600; font-size: 0.625rem;">
                                                            {% if page.diff_status_tablet == 'completed' %}
                                                                {% if page.diff_mismatch_pct_tablet is not none %}{{ "%.1f"|format(page.diff_mismatch_pct_tablet) }}%{% else %}0.0%{% endif %}
                                                            {% elif page.diff_status_tablet == 'failed' %}!
                                                            {% elif page.diff_status_tablet == 'no_baseline' %}?
                                                            {% else %}-
                                                            {% endif %}
                                                        </small>
                                                    </div>
                                                    
                                                    <!-- Mobile Viewport Icon -->
                                                    {% set mobile_clickable = page.diff_status_mobile == 'completed' %}
                                                    <div class="viewport-icon-inline clickable"
                                                         style="cursor: pointer; display: flex; flex-direction: column; align-items: center; padding: 0.25rem; min-width: 35px;"
                                                         title="Mobile - {{ 'Click to view images' if mobile_clickable else 'Click to view available images' }}"
                                                         data-page-id="{{ page.id }}"
                                                         data-page-name="{{ (page.page_name or page.path or 'Untitled Page')|e }}"
                                                         data-page-path="{{ (page.path or '/')|e }}"
                                                         data-viewport="mobile"
                                                         data-diff-pct="{{ page.diff_mismatch_pct_mobile or 0 }}"
                                                         data-last-crawled="{{ page.last_run_at or '' }}"
                                                         data-status="{{ page.diff_status_mobile or 'not_started' }}">
                                                        <span class="viewport-emoji" style="font-size: 1.1rem; margin-bottom: 0.125rem;"><i class="fas fa-mobile-alt"></i></span>
                                                        <small style="color: {% if page.diff_status_mobile == 'completed' %}{% if page.diff_mismatch_pct_mobile and page.diff_mismatch_pct_mobile > 5 %}var(--danger-color){% elif page.diff_mismatch_pct_mobile and page.diff_mismatch_pct_mobile > 1 %}var(--warning-color){% else %}var(--success-color){% endif %}{% elif page.diff_status_mobile == 'failed' %}var(--danger-color){% elif page.diff_status_mobile == 'no_baseline' %}var(--warning-color){% else %}var(--subtle-text){% endif %}; font-weight: 600; font-size: 0.625rem;">
                                                            {% if page.diff_status_mobile == 'completed' %}
                                                                {% if page.diff_mismatch_pct_mobile is not none %}{{ "%.1f"|format(page.diff_mismatch_pct_mobile) }}%{% else %}0.0%{% endif %}
                                                            {% elif page.diff_status_mobile == 'failed' %}!
                                                            {% elif page.diff_status_mobile == 'no_baseline' %}?
                                                            {% else %}-
                                                            {% endif %}
                                                        </small>
                                                    </div>
                                                </div>
                                            </td>
                                        </tr>
                                    {% endfor %}
                                </tbody>
                            </table>
                        </div>

                        <!-- Pagination -->
                        {% if pagination and pagination.pages > 1 %}
                            <div class="d-flex justify-content-center align-items-center mt-3 px-3 pb-3">
                                <nav aria-label="Page navigation">
                                    <ul class="pagination pagination-sm mb-0">
                                        {% if pagination.has_prev %}
                                            <li class="page-item">
                                                <a class="page-link" href="{{ url_for('project_details', project_id=project.id, page=pagination.prev_num) }}">
                                                    <i class="fas fa-chevron-left"></i>
                                                </a>
                                            </li>
                                        {% else %}
                                            <li class="page-item disabled">
                                                <span class="page-link">
                                                    <i class="fas fa-chevron-left"></i>
                                                </span>
                                            </li>
                                        {% endif %}

                                        {% for page_num in pagination.iter_pages() %}
                                            {% if page_num %}
                                                {% if page_num != pagination.page %}
                                                    <li class="page-item">
                                                        <a class="page-link" href="{{ url_for('project_details', project_id=project.id, page=page_num) }}">{{ page_num }}</a>
                                                    </li>
                                                {% else %}
                                                    <li class="page-item active">
                                                        <span class="page-link">{{ page_num }}</span>
                                                    </li>
                                                {% endif %}
                                            {% else %}
                                                <li class="page-item disabled">
                                                    <span class="page-link"></span>
                                                </li>
                                            {% endif %}
                                        {% endfor %}

                                        {% if pagination.has_next %}
                                            <li class="page-item">
                                                <a class="page-link" href="{{ url_for('project_details', project_id=project.id, page=pagination.next_num) }}">
                                                    <i class="fas fa-chevron-right"></i>
                                                </a>
                                            </li>
                                        {% else %}
                                            <li class="page-item disabled">
                                                <span class="page-link">
                                                    <i class="fas fa-chevron-right"></i>
                                                </span>
                                            </li>
                                        {% endif %}
                                    </ul>
                                </nav>
                            </div>
                        {% endif %}
                    {% else %}
                        <div class="empty-state">
                            <div class="empty-icon">
                                <i class="fas fa-search"></i>
                            </div>
                            <h3 class="empty-title">No Pages Discovered</h3>
                            <p class="empty-description">
                                Start crawling to discover pages on your website. The crawler will automatically find all accessible pages.
                            </p>
                        </div>
                    {% endif %}
                </div>
            </div>

        </div>
    </div>

    <!-- Delete Confirmation Modal -->
    <div class="modal fade" id="deleteModal" tabindex="-1">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Delete Project</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <p>Are you sure you want to delete the project <strong>"{{ project.name }}"</strong>?</p>
                    <p style="color: var(--danger-color);">
                        <i class="fas fa-exclamation-triangle me-2"></i>
                        This action cannot be undone. All discovered pages and data will be permanently deleted.
                    </p>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn-action btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <form method="POST" action="{{ url_for('delete_project', project_id=project.id) }}" class="d-inline">
                        <button type="submit" class="btn-action btn-danger">
                            <i class="fas fa-trash"></i>Delete Project
                        </button>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <!-- History Modal -->
    <div class="modal fade" id="historyModal" tabindex="-1" aria-labelledby="historyModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="historyModalLabel">
                        <i class="fas fa-history me-2"></i>Project History - {{ project.name }}
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <!-- Run Selector -->
                    <div class="row mb-4">
                        <div class="col-md-6">
                            <label for="runSelector" class="form-label">
                                <i class="fas fa-clock me-1"></i>Select Process Run
                            </label>
                            <select class="form-select" id="runSelector">
                                <option value="">Loading runs...</option>
                            </select>
                        </div>
                        <div class="col-md-6">
                            <div class="d-flex align-items-end h-100">
                                <div class="run-info" id="runInfo" style="display: none;">
                                    <small class="text-muted">
                                        <i class="fas fa-info-circle me-1"></i>
                                        <span id="runDetails"></span>
                                    </small>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Pages Accordion -->
                    <div id="historyAccordionContainer" style="display: none;">
                        <div class="accordion" id="historyAccordion">
                            <!-- Dynamic accordion content will be loaded here -->
                        </div>
                    </div>
                    
                    <!-- Pagination Controls -->
                    <div class="d-flex justify-content-between align-items-center mt-3" id="historyPagination" style="display: none;">
                        <div class="pagination-info">
                            <small class="text-muted" id="paginationInfo">Showing 1 to 10 of 50 entries</small>
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            <div class="d-flex align-items-center gap-2">
                                <label for="historyPerPage" class="form-label mb-0 small">Per page:</label>
                                <select class="form-select form-select-sm" id="historyPerPage" style="width: auto;">
                                    <option value="10">10</option>
                                    <option value="20">20</option>
                                    <option value="50">50</option>
                                </select>
                            </div>
                            <nav aria-label="History pagination">
                                <ul class="pagination pagination-sm mb-0" id="historyPaginationNav">
                                    <!-- Pagination buttons will be generated here -->
                                </ul>
                            </nav>
                        </div>
                    </div>

                    <!-- Loading State -->
                    <div class="text-center py-5" id="historyLoading" style="display: none;">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-3 text-muted">Loading history data...</p>
                    </div>

                    <!-- Empty State -->
                    <div class="empty-state" id="historyEmpty" style="display: none;">
                        <div class="empty-icon">
                            <i class="fas fa-history"></i>
                        </div>
                        <h3 class="empty-title">No History Available</h3>
                        <p class="empty-description">
                            No process runs found for this project. Start crawling to generate history data.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Screenshot Viewer Modal -->
    <div class="modal fade" id="screenshotModal" tabindex="-1" aria-labelledby="screenshotModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-fullscreen">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="screenshotModalLabel">
                        <i class="fas fa-image me-2"></i>Screenshot Viewer
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
<!-- Enhanced Visual Diff Viewer Modal -->
    <div class="modal fade" id="visualDiffModal" tabindex="-1" aria-labelledby="visualDiffModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-xl">
            <div class="modal-content">
                <div class="modal-header d-flex justify-content-between align-items-center">
                    <h5 class="modal-title" id="visualDiffModalLabel">
                        <span id="diffPageTitle">Page Title</span>
                    </h5>
                    <div class="d-flex align-items-center gap-3">
                        <!-- Toggle Options in Top-Right -->
                        <div class="btn-group" role="group" aria-label="View modes">
                            <input type="radio" class="btn-check" name="diffViewMode" id="sideBySideMode" value="side-by-side" checked>
                            <label class="btn btn-outline-primary btn-sm" for="sideBySideMode">
                                <i class="fas fa-columns me-1"></i>Side by Side
                            </label>
                            
                            <input type="radio" class="btn-check" name="diffViewMode" id="diffOnlyMode" value="diff-only">
                            <label class="btn btn-outline-primary btn-sm" for="diffOnlyMode">
                                <i class="fas fa-search-plus me-1"></i>Diff Only
                            </label>
                        </div>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                </div>
                <div class="modal-body p-0">
                    <!-- Side-by-Side View (3 Aligned Preview Sections) -->
                    <div id="sideBySideViewDiff" class="diff-view-mode">
                        <div class="row g-0">
                            <div class="col-md-4 border-end">
                                <div class="diff-section-header bg-light p-3 border-bottom">
                                    <h6 class="mb-0 text-center">
                                        <i class="fas fa-globe me-2 text-success"></i>Production
                                    </h6>
                                </div>
                                <div class="diff-section-body text-center p-3">
                                    <img id="diffProductionSide" src="" alt="Production Screenshot" class="img-fluid diff-section-img" style="max-height: 70vh; border-radius: 4px; border: 1px solid var(--border-color);">
                                    <div class="diff-section-overlay position-absolute top-50 start-50 translate-middle" style="opacity: 0; transition: opacity 0.2s;">
                                        <button class="btn btn-light btn-sm" onclick="expandImage('production')">
                                            <i class="fas fa-expand"></i> Expand
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4 border-end">
                                <div class="diff-section-header bg-light p-3 border-bottom">
                                    <h6 class="mb-0 text-center">
                                        <i class="fas fa-flask me-2 text-warning"></i>Staging
                                    </h6>
                                </div>
                                <div class="diff-section-body text-center p-3">
                                    <img id="diffStagingSide" src="" alt="Staging Screenshot" class="img-fluid diff-section-img" style="max-height: 70vh; border-radius: 4px; border: 1px solid var(--border-color);">
                                    <div class="diff-section-overlay position-absolute top-50 start-50 translate-middle" style="opacity: 0; transition: opacity 0.2s;">
                                        <button class="btn btn-light btn-sm" onclick="expandImage('staging')">
                                            <i class="fas fa-expand"></i> Expand
                                        </button>
                                    </div>
                                </div>
                            </div>
                            <div class="col-md-4">
                                <div class="diff-section-header bg-light p-3 border-bottom">
                                    <h6 class="mb-0 text-center">
                                        <i class="fas fa-search-plus me-2 text-danger"></i>Difference
                                    </h6>
                                </div>
                                <div class="diff-section-body text-center p-3">
                                    <img id="diffDifferenceSide" src="" alt="Difference Screenshot" class="img-fluid diff-section-img" style="max-height: 70vh; border-radius: 4px; border: 1px solid var(--border-color);">
                                    <div class="diff-section-overlay position-absolute top-50 start-50 translate-middle" style="opacity: 0; transition: opacity 0.2s;">
                                        <button class="btn btn-light btn-sm" onclick="expandImage('difference')">
                                            <i class="fas fa-expand"></i> Expand
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Diff Only View -->
                    <div id="diffOnlyViewDiff" class="diff-view-mode" style="display: none;">
                        <div class="text-center p-4">
                            <div class="diff-section-header bg-light p-3 border-bottom mb-3">
                                <h6 class="mb-0 text-center">
                                    <i class="fas fa-search-plus me-2 text-danger"></i>Visual Differences
                                </h6>
                            </div>
                            <img id="diffOnlyImage" src="" alt="Difference Only" class="img-fluid" style="max-height: 80vh; border-radius: 4px; border: 1px solid var(--border-color);">
                        </div>
                    </div>
                </div>
                
                <!-- Footer Information -->
                <div class="modal-footer bg-light d-flex justify-content-between align-items-center">
                    <div class="d-flex align-items-center gap-4">
                        <div class="d-flex align-items-center gap-2">
                            <span class="text-muted small">Viewport:</span>
                            <div class="d-flex align-items-center gap-1">
                                <div id="diffViewportIcon" class="viewport-icon-small">
                                    <i class="fas fa-desktop"></i>
                                </div>
                                <span id="diffViewportLabel" class="fw-medium">Desktop</span>
                            </div>
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            <span class="text-muted small">Difference:</span>
                            <div id="diffPercentage">
                                <span class="badge bg-success">0.0%</span>
                            </div>
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            <span class="text-muted small">Last Crawled:</span>
                            <span id="diffLastCrawled" class="fw-medium">Never</span>
                        </div>
                    </div>
                    <div class="d-flex align-items-center gap-2">
                        <small class="text-muted" id="diffPagePath">/page/path</small>
                    </div>
                </div>
            </div>
        </div>
    </div>
                <div class="modal-body p-0">
                    <!-- View Mode Toggle -->
                    <div class="bg-light border-bottom p-3">
                        <div class="row align-items-center">
                            <div class="col-md-6">
                                <h6 class="mb-0" id="screenshotPageTitle">Page Title</h6>
                                <small class="text-muted" id="screenshotPagePath">/page/path</small>
                            </div>
                            <div class="col-md-6 text-end">
                                <div class="btn-group" role="group" aria-label="View modes">
                                    <input type="radio" class="btn-check" name="viewMode" id="sideBySide" value="side-by-side" checked>
                                    <label class="btn btn-outline-primary btn-sm" for="sideBySide">
                                        <i class="fas fa-columns me-1"></i>Side by Side
                                    </label>

                                    <input type="radio" class="btn-check" name="viewMode" id="overlay" value="overlay">
                                    <label class="btn btn-outline-primary btn-sm" for="overlay">
                                        <i class="fas fa-layer-group me-1"></i>Overlay
                                    </label>

                                    <input type="radio" class="btn-check" name="viewMode" id="diffOnly" value="diff-only">
                                    <label class="btn btn-outline-primary btn-sm" for="diffOnly">
                                        <i class="fas fa-search-plus me-1"></i>Diff Only
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Screenshot Content -->
                    <div class="screenshot-content" style="height: calc(100vh - 120px); overflow: auto;">
                        <!-- Side by Side View -->
                        <div id="sideBySideView" class="view-mode active">
                            <div class="row g-0 h-100">
                                <div class="col-md-4 border-end">
                                    <div class="p-3 bg-light border-bottom">
                                        <h6 class="mb-0 text-center">
                                            <i class="fas fa-flask me-1 text-warning"></i>Staging
                                        </h6>
                                    </div>
                                    <div class="text-center p-3">
                                        <img id="stagingImage" src="" alt="Staging Screenshot" class="img-fluid screenshot-image" style="max-height: 80vh; cursor: zoom-in;">
                                    </div>
                                </div>
                                <div class="col-md-4 border-end">
                                    <div class="p-3 bg-light border-bottom">
                                        <h6 class="mb-0 text-center">
                                            <i class="fas fa-globe me-1 text-success"></i>Production
                                        </h6>
                                    </div>
                                    <div class="text-center p-3">
                                        <img id="productionImage" src="" alt="Production Screenshot" class="img-fluid screenshot-image" style="max-height: 80vh; cursor: zoom-in;">
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="p-3 bg-light border-bottom">
                                        <h6 class="mb-0 text-center">
                                            <i class="fas fa-search-plus me-1 text-danger"></i>Difference
                                        </h6>
                                    </div>
                                    <div class="text-center p-3">
                                        <img id="diffImage" src="" alt="Difference Screenshot" class="img-fluid screenshot-image" style="max-height: 80vh; cursor: zoom-in;">
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Overlay View -->
                        <div id="overlayView" class="view-mode" style="display: none;">
                            <div class="text-center p-3">
                                <div class="position-relative d-inline-block">
                                    <img id="overlayBaseImage" src="" alt="Base Screenshot" class="img-fluid screenshot-image" style="max-height: 80vh;">
                                    <img id="overlayTopImage" src="" alt="Overlay Screenshot" class="img-fluid screenshot-image position-absolute top-0 start-0" style="max-height: 80vh; opacity: 0.5;">
                                </div>
                                <div class="mt-3">
                                    <label for="opacitySlider" class="form-label">Overlay Opacity</label>
                                    <input type="range" class="form-range" id="opacitySlider" min="0" max="100" value="50">
                                </div>
                            </div>
                        </div>

                        <!-- Diff Only View -->
                        <div id="diffOnlyView" class="view-mode" style="display: none;">
                            <div class="text-center p-3">
                                <img id="diffOnlyImage" src="" alt="Difference Only" class="img-fluid screenshot-image" style="max-height: 90vh; cursor: zoom-in;">
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('open');
        }

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', function(event) {
            const sidebar = document.getElementById('sidebar');
            const menuBtn = document.querySelector('.mobile-menu-btn');
            
            if (window.innerWidth <= 768 && 
                !sidebar.contains(event.target) && 
                !menuBtn.contains(event.target) &&
                sidebar.classList.contains('open')) {
                sidebar.classList.remove('open');
            }
        });

        // Handle window resize
        window.addEventListener('resize', function() {
            const sidebar = document.getElementById('sidebar');
            if (window.innerWidth > 768) {
                sidebar.classList.remove('open');
            }
        });


        // Manual capture button functionality with asynchronous job polling
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('manual-capture-btn') || e.target.closest('.manual-capture-btn')) {
                const button = e.target.classList.contains('manual-capture-btn') ? e.target : e.target.closest('.manual-capture-btn');
                const pageId = button.getAttribute('data-page-id');
                const pageName = button.getAttribute('data-page-name');
                
                // Check if button is already disabled (job running)
                if (button.disabled) {
                    return;
                }
                
                // Disable button and show queued status
                button.disabled = true;
                const originalHtml = button.innerHTML;
                button.innerHTML = '<i class="fas fa-clock"></i> Queued...';
                
                // Update row status to queued immediately
                updateRowStatusImmediate(pageId, 'queued', 'Job queued for capture & diff generation...');
                
                // Prepare request payload with default settings including difference generation
                const requestPayload = {
                    viewports: ['desktop', 'tablet', 'mobile'],  // All viewports
                    generate_diff: true,  // Enable difference generation
                    compare_with_production: true,  // Compare staging with production
                    force_diff_generation: true,  // Force diff image generation even when no differences
                    always_create_diff_image: true  // Always create diff image regardless of difference percentage
                };
                
                // Make AJAX request to queue the manual capture job
                fetch(`{{ url_for('manual_capture_page', project_id=project.id, page_id=0) }}`.replace('0', pageId), {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestPayload)
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        // Show success toast for job queuing
                        showToast('info', data.message);
                        
                        // Update button to show processing status
                        button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processing...';
                        
                        // Start polling for job status
                        startJobStatusPolling(pageId, button, originalHtml);
                        
                        // Update row status to processing
                        updateRowStatusImmediate(pageId, 'capturing', 'Processing screenshots & differences...');
                    } else {
                        // Show error toast
                        showToast('error', data.message);
                        
                        // Re-enable button
                        button.disabled = false;
                        button.innerHTML = originalHtml;
                        
                        // Update row status to failed
                        updateRowStatusImmediate(pageId, 'failed', data.message);
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    showToast('error', `Error queuing capture job: ${error.message}`);
                    
                    // Re-enable button
                    button.disabled = false;
                    button.innerHTML = originalHtml;
                    
                    // Update row status to failed
                    updateRowStatusImmediate(pageId, 'failed', 'Failed to queue job');
                });
            }
        });

        // Function to start polling for job status - FIXED: Enhanced termination logic
        function startJobStatusPolling(pageId, button, originalHtml) {
            console.log(`Starting manual capture polling for page ${pageId}`);
            
            let pollCount = 0;
            const maxPolls = 150; // Maximum 5 minutes (150 * 2 seconds)
            
            const pollInterval = setInterval(() => {
                pollCount++;
                console.log(`Manual capture polling attempt ${pollCount} for page ${pageId}`);
                
                // Safety check: Stop polling after max attempts
                if (pollCount >= maxPolls) {
                    console.log(`Maximum polling attempts reached for page ${pageId}. Stopping polling.`);
                    clearInterval(pollInterval);
                    if (button.disabled) {
                        button.disabled = false;
                        button.innerHTML = originalHtml;
                        showToast('warning', 'Job status polling timed out. Please refresh the page to see current status.');
                    }
                    return;
                }
                
                fetch(`{{ url_for('manual_capture_status', project_id=project.id, page_id=0) }}`.replace('0', pageId))
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success) {
                            const jobStatus = data.job_status.status;
                            const pageStatus = data.page_status;
                            const progress = data.progress;
                            
                            console.log(`Page ${pageId} job status: ${jobStatus}, page status: ${pageStatus}`);
                            
                            // Update button text based on progress
                            if (progress && progress.message) {
                                const progressText = progress.progress ? `${progress.progress}%` : '';
                                button.innerHTML = `<i class="fas fa-spinner fa-spin"></i> ${progress.message} ${progressText}`;
                            }
                            
                            // Update row status based on current page status
                            if (pageStatus) {
                                let statusMessage = 'Processing...';
                                if (progress && progress.message) {
                                    statusMessage = progress.message;
                                }
                                updateRowStatusImmediate(pageId, pageStatus, statusMessage);
                            }
                            
                            // FIXED: Enhanced completion check with explicit termination
                            if (jobStatus === 'not_scheduled' && (pageStatus === 'completed' || pageStatus === 'failed')) {
                                console.log(`Page ${pageId} job completed with status: ${pageStatus}. Stopping polling immediately.`);
                                
                                // Immediately clear the interval
                                clearInterval(pollInterval);
                                
                                if (pageStatus === 'completed') {
                                    // Success
                                    showToast('success', `Screenshot capture & difference generation completed for page!`);
                                    button.innerHTML = '<i class="fas fa-check"></i> Completed';
                                    
                                    // Update row with completion data
                                    updateRowStatusImmediate(pageId, 'completed', 'Screenshots & differences generated successfully');
                                    
                                    // Re-enable button after delay
                                    setTimeout(() => {
                                        button.disabled = false;
                                        button.innerHTML = originalHtml;
                                    }, 3000);
                                    
                                    // Refresh page to show updated results
                                    setTimeout(() => {
                                        location.reload();
                                    }, 4000);
                                } else {
                                    // Failed
                                    showToast('error', `Screenshot capture & difference generation failed for page.`);
                                    button.innerHTML = '<i class="fas fa-times"></i> Failed';
                                    
                                    // Update row with failure status
                                    updateRowStatusImmediate(pageId, 'screenshot_failed', 'Screenshot capture & diff generation failed');
                                    
                                    // Re-enable button after delay
                                    setTimeout(() => {
                                        button.disabled = false;
                                        button.innerHTML = originalHtml;
                                    }, 3000);
                                }
                                
                                // Exit the function to prevent further execution
                                return;
                            }
                        } else {
                            console.warn(`Invalid response for page ${pageId}:`, data);
                        }
                    })
                    .catch(error => {
                        console.error(`Error polling job status for page ${pageId}:`, error);
                        
                        // Stop polling on network errors to prevent infinite requests
                        if (error.message.includes('Failed to fetch') ||
                            error.message.includes('NetworkError') ||
                            error.message.includes('HTTP 500') ||
                            error.message.includes('HTTP 404')) {
                            console.log(`Network/Server error detected for page ${pageId}. Stopping manual capture polling.`);
                            clearInterval(pollInterval);
                            if (button.disabled) {
                                button.disabled = false;
                                button.innerHTML = originalHtml;
                                showToast('error', 'Job polling stopped due to network error. Please refresh the page to check current status.');
                            }
                        }
                    });
            }, 2000); // Poll every 2 seconds
        }

        // Function to update row status immediately (for real-time feedback)
        function updateRowStatusImmediate(pageId, status, message) {
            const row = document.querySelector(`button[data-page-id="${pageId}"]`)?.closest('tr');
            if (!row) return;
            
            // Update Find Difference Status column (4th column, 0-indexed = 3)
            const statusCell = row.cells[3];
            if (statusCell) {
                let statusHtml = '';
                let statusClass = '';
                
                switch(status) {
                    case 'queued':
                        statusHtml = '<span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);"><i class="fas fa-clock me-1"></i>QUEUED</span>';
                        break;
                    case 'capturing':
                    case 'finding_difference':
                        statusHtml = '<span class="status-badge" style="background: rgba(147, 51, 234, 0.1); color: #9333ea;"><i class="fas fa-search-plus me-1"></i>FINDING DIFFERENCE</span>';
                        break;
                    case 'completed':
                    case 'ready':
                        statusHtml = '<div class="d-flex flex-column"><span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);"><i class="fas fa-check-circle me-1"></i>COMPLETED</span>';
                        if (message && !message.includes('Processing') && !message.includes('Queued')) {
                            statusHtml += `<small style="color: var(--subtle-text); font-size: 0.75rem; margin-top: 0.25rem;">Completed just now</small>`;
                        }
                        statusHtml += '</div>';
                        break;
                    case 'failed':
                    case 'diff_failed':
                    case 'error':
                    case 'screenshot_failed':
                        statusHtml = '<div class="d-flex flex-column"><span class="status-badge" style="background: rgba(239, 68, 68, 0.1); color: var(--danger-color);"><i class="fas fa-times-circle me-1"></i>FAILED</span>';
                        if (message) {
                            statusHtml += `<small style="color: var(--danger-color); font-size: 0.75rem; margin-top: 0.25rem; font-weight: 500;">Error: ${message}</small>`;
                        } else {
                            // Provide default error messages based on status type
                            if (status === 'screenshot_failed') {
                                statusHtml += `<small style="color: var(--danger-color); font-size: 0.75rem; margin-top: 0.25rem; font-weight: 500;">Screenshot capture failed</small>`;
                            } else if (status === 'diff_failed') {
                                statusHtml += `<small style="color: var(--danger-color); font-size: 0.75rem; margin-top: 0.25rem; font-weight: 500;">Difference generation failed</small>`;
                            } else {
                                statusHtml += `<small style="color: var(--danger-color); font-size: 0.75rem; margin-top: 0.25rem; font-weight: 500;">Process failed</small>`;
                            }
                        }
                        statusHtml += '</div>';
                        break;
                    default:
                        statusHtml = `<span class="status-badge secondary"><i class="fas fa-minus-circle me-1"></i>${status.toUpperCase()}</span>`;
                        if (message) {
                            statusHtml += `<small style="color: var(--subtle-text); display: block; margin-top: 2px;">${message}</small>`;
                        }
                }
                
                statusCell.innerHTML = statusHtml;
            }
            
            // Update Last Run column (5th column, 0-indexed = 4)
            if (status === 'completed' || status === 'capturing') {
                const lastRunCell = row.cells[4];
                if (lastRunCell) {
                    const now = new Date();
                    const dateStr = now.toLocaleDateString('en-GB', {
                        timeZone: 'Asia/Kolkata',
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric'
                    });
                    const timeStr = now.toLocaleTimeString('en-US', {
                        timeZone: 'Asia/Kolkata',
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: true
                    });
                    lastRunCell.innerHTML = `
                        <div class="d-flex flex-column">
                            <small style="color: var(--primary-text); font-weight: 500;">${dateStr}</small>
                            <small style="color: var(--subtle-text); font-size: 0.75rem;">${timeStr}</small>
                        </div>
                    `;
                }
            }
        }

        // Function to update row status live
        function updateRowStatus(pageId, data) {
            const row = document.querySelector(`input[data-page-id="${pageId}"]`)?.closest('tr');
            if (!row) return;
            
            // Update Find Difference Status column
            const statusCell = row.cells[3]; // 4th column (0-indexed)
            if (statusCell) {
                let statusHtml = '';
                if (data.updated_status === 'captured') {
                    statusHtml = '<span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);">Screenshots Captured</span>';
                } else if (data.updated_status === 'capturing') {
                    statusHtml = '<span class="status-badge warning">Capturing Screenshots</span>';
                }
                
                
                statusCell.innerHTML = statusHtml;
            }
            
            // Update Last Run column
            const lastRunCell = row.cells[4]; // 5th column (0-indexed)
            if (lastRunCell) {
                const now = new Date();
                const dateStr = now.toLocaleDateString('en-GB', {
                    timeZone: 'Asia/Kolkata',
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                });
                const timeStr = now.toLocaleTimeString('en-US', {
                    timeZone: 'Asia/Kolkata',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true
                });
                lastRunCell.innerHTML = `
                    <div class="d-flex flex-column">
                        <small style="color: var(--primary-text); font-weight: 500;">${dateStr}</small>
                        <small style="color: var(--subtle-text); font-size: 0.75rem;">${timeStr}</small>
                    </div>
                `;
            }
            
            // Update Results column to show baseline set for first run
            const resultsCell = row.cells[6]; // 7th column (0-indexed)
            if (resultsCell && data.updated_status === 'captured') {
                // Show baseline set indicators for all viewports
                resultsCell.innerHTML = `
                    <div class="d-flex flex-column gap-1">
                        <div class="d-flex gap-1 align-items-center">
                            <i class="fas fa-desktop text-muted" style="width: 16px;"></i>
                            <small class="text-success">Baseline set</small>
                        </div>
                        <div class="d-flex gap-1 align-items-center">
                            <i class="fas fa-tablet-alt text-muted" style="width: 16px;"></i>
                            <small class="text-success">Baseline set</small>
                        </div>
                        <div class="d-flex gap-1 align-items-center">
                            <i class="fas fa-mobile-alt text-muted" style="width: 16px;"></i>
                            <small class="text-success">Baseline set</small>
                        </div>
                    </div>
                `;
            }
        }

        // Toast notification function
        function showToast(type, message) {
            // Create toast element
            const toast = document.createElement('div');
            
            // Map toast types to Bootstrap alert classes
            let alertClass = 'alert-info'; // default
            if (type === 'success' || type === 'info') {
                alertClass = 'alert-success'; // Green for both success and info
            } else if (type === 'error' || type === 'danger') {
                alertClass = 'alert-danger'; // Red for errors
            } else if (type === 'warning') {
                alertClass = 'alert-warning'; // Yellow for warnings
            }
            
            toast.className = `alert ${alertClass} alert-dismissible fade show`;
            toast.style.position = 'fixed';
            toast.style.top = '20px';
            toast.style.right = '20px';
            toast.style.zIndex = '9999';
            toast.style.minWidth = '300px';
            toast.innerHTML = `
                ${message}
                <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
            `;
            
            // Add to page
            document.body.appendChild(toast);
            
            // Auto-remove after 5 seconds
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 5000);
        }

        // NEW: Function to update per-page status display
        function updatePerPageStatusDisplay(pagesStatus) {
            console.log('Updating per-page status display for', pagesStatus.length, 'pages');
            
            if (!pagesStatus || !Array.isArray(pagesStatus)) {
                console.warn('Invalid pages status data:', pagesStatus);
                return;
            }
            
            // Update each page's status in the discovered pages table
            pagesStatus.forEach(pageStatus => {
                const pageId = pageStatus.page_id;
                const findDiffStatus = pageStatus.find_diff_status;
                const currentRunId = pageStatus.current_run_id;
                const lastRunAt = pageStatus.last_run_at;
                
                console.log(`Updating page ${pageId}: status=${findDiffStatus}, run=${currentRunId}`);
                
                // Find the table row for this page
                const pageRow = document.querySelector(`input[data-page-id="${pageId}"]`)?.closest('tr');
                if (!pageRow) {
                    console.warn(`Page row not found for page ID ${pageId}`);
                    return;
                }
                
                // Update the "Difference Status" column (4th column, index 4)
                const statusCell = pageRow.cells[4];
                if (statusCell) {
                    let statusHtml = '';
                    
                    switch(findDiffStatus) {
                        case 'ready':
                            statusHtml = `
                                <span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);">
                                    <i class="fas fa-check-circle me-1"></i>READY
                                </span>
                            `;
                            break;
                        case 'finding_difference':
                            statusHtml = `
                                <span class="status-badge" style="background: rgba(147, 51, 234, 0.1); color: #9333ea;">
                                    <i class="fas fa-search-plus me-1"></i>FINDING DIFFERENCE
                                </span>
                            `;
                            break;
                        case 'capturing':
                            statusHtml = `
                                <span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);">
                                    <i class="fas fa-camera me-1"></i>CAPTURING
                                </span>
                            `;
                            break;
                        case 'captured':
                            statusHtml = `
                                <span class="status-badge" style="background: rgba(245, 158, 11, 0.1); color: var(--warning-color);">
                                    <i class="fas fa-image me-1"></i>CAPTURED
                                </span>
                            `;
                            break;
                        case 'diffing':
                            statusHtml = `
                                <span class="status-badge" style="background: rgba(147, 51, 234, 0.1); color: #9333ea;">
                                    <i class="fas fa-search-plus me-1"></i>DIFFING
                                </span>
                            `;
                            break;
                        case 'failed':
                        case 'diff_failed':
                            statusHtml = `
                                <span class="status-badge" style="background: rgba(239, 68, 68, 0.1); color: var(--danger-color);">
                                    <i class="fas fa-times-circle me-1"></i>FAILED
                                </span>
                            `;
                            break;
                        case 'pending':
                        default:
                            statusHtml = `
                                <span class="status-badge secondary">
                                    <i class="fas fa-clock me-1"></i>PENDING
                                </span>
                            `;
                    }
                    
                    statusCell.innerHTML = statusHtml;
                }
                
                // Update the "Last Run" column (6th column, index 6) if we have a recent run
                if (lastRunAt && pageRow.cells[6]) {
                    const lastRunCell = pageRow.cells[6];
                    const runDate = new Date(lastRunAt);
                    const dateStr = runDate.toLocaleDateString('en-GB', {
                        day: '2-digit',
                        month: '2-digit',
                        year: 'numeric'
                    });
                    const timeStr = runDate.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit',
                        hour12: true
                    });
                    
                    lastRunCell.innerHTML = `
                        <div class="d-flex flex-column">
                            <small style="color: var(--primary-text); font-weight: 500;">${dateStr}</small>
                            <small style="color: var(--subtle-text); font-size: 0.75rem;">${timeStr}</small>
                        </div>
                    `;
                }
                
                // Update viewport status indicators if available
                if (pageStatus.viewports) {
                    updateViewportStatusIndicators(pageRow, pageStatus.viewports);
                }
            });
        }
        
        // Helper function to update viewport status indicators
        function updateViewportStatusIndicators(pageRow, viewports) {
            const resultsCell = pageRow.cells[7]; // Results column (8th column, index 7)
            if (!resultsCell) return;
            
            const viewportIcons = resultsCell.querySelectorAll('.viewport-icon-inline');
            
            // Update each viewport icon based on status
            ['desktop', 'tablet', 'mobile'].forEach((viewport, index) => {
                const viewportData = viewports[viewport];
                if (!viewportData || !viewportIcons[index]) return;
                
                const icon = viewportIcons[index];
                const statusElement = icon.querySelector('small');
                if (!statusElement) return;
                
                const status = viewportData.status;
                const diffPct = viewportData.diff_mismatch_pct;
                const errorMsg = viewportData.error_message;
                
                let displayText = '-';
                let color = 'var(--subtle-text)';
                let title = `${viewport} - ${status}`;
                
                switch(status) {
                    case 'completed':
                        if (diffPct !== null && diffPct !== undefined) {
                            displayText = `${Number(diffPct).toFixed(1)}%`;
                            color = diffPct > 5 ? 'var(--danger-color)' : diffPct > 1 ? 'var(--warning-color)' : 'var(--success-color)';
                            title = `${viewport} - ${Number(diffPct).toFixed(2)}% difference`;
                        } else {
                            displayText = '0.0%';
                            color = 'var(--success-color)';
                            title = `${viewport} - Completed`;
                        }
                        break;
                    case 'failed':
                        displayText = '!';
                        color = 'var(--danger-color)';
                        title = `${viewport} - Failed${errorMsg ? ': ' + errorMsg : ''}`;
                        break;
                    case 'no_baseline':
                        displayText = '?';
                        color = 'var(--warning-color)';
                        title = `${viewport} - No Baseline`;
                        break;
                    case 'capturing':
                        displayText = '';
                        color = 'var(--accent-color)';
                        title = `${viewport} - Capturing Screenshots`;
                        break;
                    case 'diffing':
                        displayText = '';
                        color = 'var(--info-color)';
                        title = `${viewport} - Finding Differences`;
                        break;
                    case 'pending':
                    default:
                        displayText = '-';
                        color = 'var(--subtle-text)';
                        title = `${viewport} - Pending`;
                }
                
                statusElement.textContent = displayText;
                statusElement.style.color = color;
                icon.title = title;
            });
        }

        // Progress tracking and status updates
        function updateProgress(progressData) {
            const progressContainer = document.getElementById('progressContainer');
            const progressBar = document.getElementById('progressBar');
            const progressMessage = document.getElementById('progressMessage');
            
            if (progressData && progressData.stage !== 'unknown') {
                progressContainer.style.display = 'block';
                progressBar.style.width = progressData.progress + '%';
                progressBar.setAttribute('aria-valuenow', progressData.progress);
                progressMessage.textContent = progressData.message;
                
                // Update progress bar color based on stage
                progressBar.className = 'progress-bar progress-bar-striped progress-bar-animated';
                if (progressData.stage === 'completed') {
                    progressBar.classList.add('bg-success');
                } else if (progressData.stage === 'error') {
                    progressBar.classList.add('bg-danger');
                } else {
                    progressBar.classList.add('bg-primary');
                }
            } else {
                progressContainer.style.display = 'none';
            }
        }

        // FIXED: Enhanced auto-refresh with proper completion detection and polling termination
        function refreshStatus() {
            fetch(`/projects/{{ project.id }}/status`)
                .then(response => response.json())
                .then(data => {
                    if (data.run_state) {
                        // Update last updated time
                        document.getElementById('lastUpdated').textContent = new Date().toLocaleString();
                        
                        // Extract the actual state from the run state data
                        const actualState = typeof data.run_state === 'object' ? data.run_state.state : data.run_state;
                        
                        // Update status display in real-time
                        updateStatusDisplay(actualState);
                        
                        // Update progress if available
                        if (data.run_state.progress) {
                            updateProgress(data.run_state.progress);
                        }
                        
                        // FIXED: Enhanced completion detection with polling termination
                        if (['result', 'job_failed', 'crawled', 'diff_failed', 'failed', 'error'].includes(actualState)) {
                            console.log(`Job completed with state: ${actualState}. Stopping status polling.`);
                            
                            // Stop the status polling immediately
                            if (window.stopStatusPolling) {
                                window.stopStatusPolling();
                            }
                            
                            // Show completion message
                            if (actualState === 'result') {
                                console.log('Crawling completed successfully!');
                            } else if (actualState === 'job_failed') {
                                console.log('Crawling job failed.');
                            } else if (actualState === 'crawled') {
                                console.log('Crawling completed.');
                            }
                            
                            // Reload page after a short delay to show updated results
                            setTimeout(() => {
                                location.reload();
                            }, 2000);
                        }
                    }
                })
                .catch(error => {
                    console.error('Error checking run state:', error);
                    
                    // Stop polling on network errors to prevent infinite requests
                    if (error.message.includes('Failed to fetch') ||
                        error.message.includes('NetworkError')) {
                        console.log('Network error detected. Stopping status polling.');
                        if (window.stopStatusPolling) {
                            window.stopStatusPolling();
                        }
                    }
                });
        }

        // Update status display without full page reload
        function updateStatusDisplay(runState) {
            const statusElement = document.getElementById('crawlStatus');
            if (!statusElement) return;
            
            let statusHtml = '';
            
            if (runState === 'not_started') {
                statusHtml = `
                    <span class="status-badge" style="background: rgba(142, 144, 147, 0.1); color: var(--subtle-text);">
                        <i class="fas fa-minus-circle me-1"></i>Not Started
                    </span>
                `;
            } else if (runState === 'crawling') {
                statusHtml = `
                    <span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);">
                        <i class="fas fa-spider me-1"></i>Crawling
                    </span>
                `;
            } else if (runState === 'crawled') {
                statusHtml = `
                    <span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);">
                        <i class="fas fa-check-circle me-1"></i>Crawled
                    </span>
                `;
            } else if (runState === 'finding_difference') {
                statusHtml = `
                    <span class="status-badge" style="background: rgba(147, 51, 234, 0.1); color: #9333ea;">
                        <i class="fas fa-search-plus me-1"></i>Finding Differences
                    </span>
                `;
            } else if (runState === 'result') {
                statusHtml = `
                    <span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);">
                        <i class="fas fa-chart-line me-1"></i>Results Available
                    </span>
                `;
            } else if (runState === 'job_failed') {
                statusHtml = `
                    <span class="status-badge" style="background: rgba(239, 68, 68, 0.1); color: var(--danger-color);">
                        <i class="fas fa-exclamation-triangle me-1"></i>Job Failed
                    </span>
                `;
            } else {
                statusHtml = `
                    <span class="status-badge secondary">
                        <i class="fas fa-minus-circle me-1"></i>Unknown Status
                    </span>
                `;
            }
            
            statusElement.innerHTML = statusHtml;
        }

        // History Modal Functionality
        var currentProjectId = parseInt('{{ project.id }}');
        var currentRunData = null;
        var currentPage = 1;
        var currentPerPage = 10;
        var currentPagination = null;

        // Load history data when modal is opened
        document.getElementById('historyModal').addEventListener('show.bs.modal', function() {
            loadHistoryRuns();
        });

        // Load available runs for the project
        function loadHistoryRuns() {
            const runSelector = document.getElementById('runSelector');
            runSelector.innerHTML = '<option value="">Loading runs...</option>';
            
            fetch(`/api/history/project/${currentProjectId}/runs`)
                .then(response => response.json())
                .then(data => {
                    runSelector.innerHTML = '';
                    
                    if (data.success && data.runs && data.runs.length > 0) {
                        // Add default option
                        runSelector.innerHTML = '<option value="">Select a process run...</option>';
                        
                        // Add runs in reverse chronological order (newest first)
                        data.runs.forEach(run => {
                            const option = document.createElement('option');
                            option.value = run.timestamp;  // Use timestamp as value
                            option.textContent = `${run.datetime} (${run.page_count} pages)`;
                            option.dataset.runData = JSON.stringify({
                                run_id: run.timestamp,
                                formatted_date: run.datetime,
                                pages_count: run.page_count,
                                timestamp: run.timestamp
                            });
                            runSelector.appendChild(option);
                        });
                        
                        // Auto-select the most recent run
                        if (data.runs.length > 0) {
                            runSelector.value = data.runs[0].timestamp;
                            onRunSelected();
                        }
                    } else {
                        runSelector.innerHTML = '<option value="">No runs available</option>';
                        showHistoryEmpty();
                    }
                })
                .catch(error => {
                    console.error('Error loading runs:', error);
                    runSelector.innerHTML = '<option value="">Error loading runs</option>';
                    showHistoryEmpty();
                });
        }

        // Handle run selection change
        document.getElementById('runSelector').addEventListener('change', onRunSelected);

        function onRunSelected() {
            const runSelector = document.getElementById('runSelector');
            const selectedOption = runSelector.options[runSelector.selectedIndex];
            
            if (!selectedOption.value) {
                hideHistoryTable();
                return;
            }
            
            // Get run data from option dataset
            try {
                currentRunData = JSON.parse(selectedOption.dataset.runData);
                
                // Update run info
                updateRunInfo(currentRunData);
                
                // Load pages for selected run - use the run_id from currentRunData
                loadHistoryPages(currentRunData.run_id);
            } catch (error) {
                console.error('Error parsing run data:', error);
                showHistoryEmpty();
            }
        }

        // Update run information display
        function updateRunInfo(runData) {
            const runInfo = document.getElementById('runInfo');
            const runDetails = document.getElementById('runDetails');
            
            runDetails.innerHTML = `
                ${runData.pages_count} pages |
                Started: ${runData.formatted_date}
            `;
            
            runInfo.style.display = 'block';
        }

        // Load pages for selected run - use backend pagination for better performance
        function loadHistoryPages(runId, page = 1, perPage = currentPerPage) {
            showHistoryLoading();
            
            // Use backend pagination for better performance
            const url = `/api/history/project/${currentProjectId}/run/${runId}/pages?page=${page}&per_page=${perPage}`;
            
            console.log(`Loading history pages for run ${runId}, page ${page}, perPage ${perPage}`);
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    hideHistoryLoading();
                    
                    if (data.success && data.pages) {
                        console.log(` Received ${data.pages.length} page records from API`);
                        
                        if (data.pages.length > 0) {
                            // Group pages by path to avoid duplicates across viewports
                            const groupedPages = groupPagesForHistory(data.pages);
                            const groupedPagesArray = Object.values(groupedPages);
                            
                            console.log(` After grouping: ${groupedPagesArray.length} unique pages`);
                            
                            // Update global pagination state from backend response
                            currentPage = data.pagination.page;
                            currentPerPage = data.pagination.per_page;
                            currentPagination = data.pagination;
                            
                            console.log(` Backend pagination:`, currentPagination);
                            
                            populateHistoryTableWithGroupedPages(groupedPagesArray);
                            updatePaginationControls(currentPagination);
                            showHistoryTable();
                            
                            console.log(` History pagination complete - showing ${groupedPagesArray.length} pages`);
                        } else {
                            // No pages on this page, but pagination info might still be valid
                            if (data.pagination && data.pagination.total > 0 && data.pagination.page > 1) {
                                // We're on a page beyond the available data, go to last page
                                const lastPage = data.pagination.pages;
                                if (lastPage > 0) {
                                    console.log(`No pages on page ${page}, redirecting to last page ${lastPage}`);
                                    loadHistoryPages(runId, lastPage, perPage);
                                    return;
                                }
                            }
                            console.log(' No pages found');
                            showHistoryEmpty();
                        }
                    } else {
                        console.log(' No pages found or API error:', data.error || 'Unknown error');
                        showHistoryEmpty();
                    }
                })
                .catch(error => {
                    console.error(' Error loading pages:', error);
                    hideHistoryLoading();
                    showHistoryEmpty();
                });
        }
        
        // Separate function to group pages for history
        function groupPagesForHistory(pages) {
            const groupedPages = {};
            pages.forEach((page, index) => {
                const key = page.path || '/'; // Use path as the unique key
                console.log(`Processing page ${index + 1}: ${key}`, page);
                
                if (!groupedPages[key]) {
                    groupedPages[key] = {
                        page_name: page.page_name,
                        path: page.path,
                        staging_url: page.staging_url,
                        last_run_at: page.last_run_at,
                        viewports: {
                            desktop: { status: 'pending', diff_percentage: null, page_id: null },
                            tablet: { status: 'pending', diff_percentage: null, page_id: null },
                            mobile: { status: 'pending', diff_percentage: null, page_id: null }
                        }
                    };
                }
                
                // Update viewport data for this page
                ['desktop', 'tablet', 'mobile'].forEach(viewport => {
                    const status = page[`diff_status_${viewport}`];
                    const diffPct = page[`diff_mismatch_pct_${viewport}`];
                    
                    // Only update if we have actual data (not null/undefined)
                    if (status) {
                        groupedPages[key].viewports[viewport] = {
                            status: status,
                            diff_percentage: diffPct,
                            page_id: page.id
                        };
                    }
                });
                
                // Update other fields if they're more recent or missing
                if (!groupedPages[key].page_name && page.page_name) {
                    groupedPages[key].page_name = page.page_name;
                }
                if (!groupedPages[key].staging_url && page.staging_url) {
                    groupedPages[key].staging_url = page.staging_url;
                }
                if (!groupedPages[key].last_run_at || (page.last_run_at && new Date(page.last_run_at) > new Date(groupedPages[key].last_run_at))) {
                    groupedPages[key].last_run_at = page.last_run_at;
                }
            });
            
            return groupedPages;
        }
        
        // Populate the history accordion with already grouped page data
        function populateHistoryTableWithGroupedPages(groupedPagesArray) {
            try {
                const accordion = document.getElementById('historyAccordion');
                if (!accordion) {
                    console.error(' historyAccordion element not found');
                    showHistoryEmpty();
                    return;
                }
                
                console.log(` populateHistoryTableWithGroupedPages called with ${groupedPagesArray.length} grouped pages`);
                
                if (!groupedPagesArray || groupedPagesArray.length === 0) {
                    console.log(' No grouped pages to display');
                    showHistoryEmpty();
                    return;
                }
                
                // Clear existing content and set up accordion
                accordion.innerHTML = '';
                accordion.className = 'accordion history-accordion';
                
                // Create accordion items for each grouped page using simpler approach
                groupedPagesArray.forEach((pageData, index) => {
                    try {
                        const pageKey = pageData.path || '/';
                        
                        // Create accordion item with simpler HTML structure
                        const accordionItem = document.createElement('div');
                        accordionItem.className = 'accordion-item history-page-item';
                        accordionItem.style.cssText = `
                            background: var(--background);
                            border: 1px solid var(--border-color);
                            border-radius: 6px;
                            margin-bottom: 0.5rem;
                            transition: all 0.2s ease;
                        `;
                        
                        // Safely escape data to prevent XSS and handle null values
                        const safePageName = (pageData.page_name || pageData.path || 'Untitled Page').replace(/[<>"'&]/g, function(match) {
                            const escapeMap = { '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '&': '&amp;' };
                            return escapeMap[match];
                        });
                        
                        const safeStagingUrl = pageData.staging_url ? pageData.staging_url.replace(/[<>"'&]/g, function(match) {
                            const escapeMap = { '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;', '&': '&amp;' };
                            return escapeMap[match];
                        }) : '';
                        
                        // Generate viewport icons HTML
                        const viewportIconsHtml = generateInlineViewportIconsFromBackend(pageData, pageKey);
                        
                        // Create the complete HTML structure
                        const stagingLinkHtml = pageData.staging_url ?
                            `<a href="${safeStagingUrl}" target="_blank" class="page-link-compact" style="font-size: 0.75rem; color: var(--accent-color); text-decoration: none; display: block;">
                                ${safeStagingUrl} <i class="fas fa-external-link-alt" style="font-size: 0.625rem;"></i>
                            </a>` : '';
                        
                        accordionItem.innerHTML = `
                            <div class="w-100 d-flex justify-content-between align-items-center py-3 px-3">
                                <div class="page-info-header flex-grow-1">
                                    <div class="page-title-compact" style="font-size: 0.875rem; font-weight: 600; color: var(--primary-text); margin-bottom: 0.25rem;">
                                        ${safePageName}
                                    </div>
                                    ${stagingLinkHtml}
                                </div>
                                <div class="viewport-icons-inline">
                                    ${viewportIconsHtml}
                                </div>
                            </div>
                        `;
                        
                        // Add to accordion
                        accordion.appendChild(accordionItem);
                        
                        console.log(` Created accordion item ${index + 1} for page: ${pageKey}`);
                    } catch (itemError) {
                        console.error(` Error creating accordion item ${index}:`, itemError);
                        console.error(' Item error details:', itemError.message, itemError.stack);
                    }
                });
                
                console.log(` Successfully populated ${groupedPagesArray.length} history items in accordion`);
                console.log(` Accordion now has ${accordion.children.length} child elements`);
                
                // Force a reflow to ensure DOM is updated
                accordion.offsetHeight;
                
            } catch (error) {
                console.error(' Error in populateHistoryTableWithGroupedPages:', error);
                console.error(' Error details:', error.message, error.stack);
                showHistoryEmpty();
            }
            
            // Add event listeners for viewport icons after DOM is updated
            setTimeout(() => {
                const clickableIcons = document.querySelectorAll('#historyAccordion .viewport-icon-inline.clickable');
                console.log(' Found clickable viewport icons in history:', clickableIcons.length);
                console.log(' All viewport icons in history:', document.querySelectorAll('#historyAccordion .viewport-icon-inline'));
                
                // Note: History viewport icons now use onclick attribute directly in HTML
                // The openHistoryImageModal function is called directly from the onclick attribute
                // No additional event listeners needed for history icons
                console.log(' History viewport icons use onclick attribute - no additional listeners needed');
                
                // Add a global click listener to test if any clicks are being captured
                document.addEventListener('click', function(e) {
                    if (e.target.closest('#historyAccordion .viewport-icon-inline')) {
                        console.log(' Global click detected on history viewport icon:', e.target);
                    }
                });
            }, 100);
        }
        
        // Generate inline viewport icons for backend-grouped pages
        function generateInlineViewportIconsFromBackend(pageData, pageKey) {
            console.log(` generateInlineViewportIconsFromBackend called for page: ${pageKey}`, pageData);
            
            const viewports = [
                { key: 'desktop', icon: 'fa-desktop', label: 'Desktop', emoji: '<i class="fas fa-desktop"></i>' },
                { key: 'tablet', icon: 'fa-tablet-alt', label: 'Tablet', emoji: '<i class="fas fa-tablet-alt"></i>' },
                { key: 'mobile', icon: 'fa-mobile-alt', label: 'Mobile', emoji: '<i class="fas fa-mobile-alt"></i>' }
            ];
            
            try {
                const iconsHtml = viewports.map(viewport => {
                    // Get viewport-specific data from the pageData object
                    const status = pageData.viewports ? pageData.viewports[viewport.key]?.status : pageData[`diff_status_${viewport.key}`] || 'pending';
                    const diffPct = pageData.viewports ? pageData.viewports[viewport.key]?.diff_percentage : pageData[`diff_mismatch_pct_${viewport.key}`];
                    const pageId = pageData.viewports ? pageData.viewports[viewport.key]?.page_id : pageData.id;
                    
                    console.log(` Viewport ${viewport.key} data:`, { status, diffPct, pageId });
                    
                    let diffText = '';
                    let diffColor = 'var(--subtle-text)';
                    if (status === 'completed' && diffPct !== null && diffPct !== undefined) {
                        diffText = `${Number(diffPct).toFixed(1)}%`;
                        diffColor = diffPct > 5 ? 'var(--danger-color)' : diffPct > 1 ? 'var(--warning-color)' : 'var(--success-color)';
                    } else if (status === 'failed') {
                        diffText = '!';
                        diffColor = 'var(--danger-color)';
                    } else if (status === 'no_baseline') {
                        diffText = '?';
                        diffColor = 'var(--warning-color)';
                    } else {
                        diffText = '-';
                        diffColor = 'var(--subtle-text)';
                    }
                    
                    const isClickable = true; // Always make clickable to allow viewing any available images
                    const buttonClass = 'viewport-icon-inline clickable';
                    const cursor = 'cursor: pointer;';
                    
                    // Use textContent for safe data attributes (no manual escaping needed)
                    const safePageId = String(pageId || '');
                    const safePageName = String(pageData.page_name || pageData.path || 'Untitled Page');
                    const safePagePath = String(pageData.path || '/');
                    const safeDiffPct = String(diffPct || 0);
                    const safeLastCrawled = String(pageData.last_run_at || '');
                    
                    // Create a more robust HTML structure
                    return `<div class="${buttonClass}" style="${cursor} display: flex; flex-direction: column; align-items: center; padding: 0.25rem; min-width: 35px;" title="${viewport.label} - Click to view images" data-page-id="${safePageId}" data-page-name="${safePageName}" data-page-path="${safePagePath}" data-viewport="${viewport.key}" data-diff-pct="${safeDiffPct}" data-last-crawled="${safeLastCrawled}"><span class="viewport-emoji" style="font-size: 1.1rem; margin-bottom: 0.125rem;">${viewport.emoji}</span><small style="color: ${diffColor}; font-weight: 600; font-size: 0.625rem;">${diffText}</small></div>`;
                }).join('');
                
                console.log(` Generated viewport icons HTML (${iconsHtml.length} chars):`, iconsHtml);
                return iconsHtml;
                
            } catch (error) {
                console.error(` Error in generateInlineViewportIconsFromBackend:`, error);
                return '<div class="text-muted small">Error loading viewport icons</div>';
            }
        }
        
        // Populate the history accordion with grouped page data
        function populateHistoryTable(pages) {
            const accordion = document.getElementById('historyAccordion');
            accordion.innerHTML = '';
            accordion.className = 'accordion history-accordion';
            
            console.log(`populateHistoryTable called with ${pages.length} pages`);
            
            // Group pages by unique page path to avoid duplicates
            const groupedPages = {};
            pages.forEach((page, index) => {
                const key = page.path || '/'; // Use path as the unique key
                console.log(`Processing page ${index + 1}: ${key}`, page);
                
                if (!groupedPages[key]) {
                    groupedPages[key] = {
                        page_name: page.page_name,
                        path: page.path,
                        staging_url: page.staging_url,
                        last_run_at: page.last_run_at,
                        viewports: {
                            desktop: { status: 'pending', diff_percentage: null, page_id: null },
                            tablet: { status: 'pending', diff_percentage: null, page_id: null },
                            mobile: { status: 'pending', diff_percentage: null, page_id: null }
                        }
                    };
                }
                
                // Update viewport data for this page
                ['desktop', 'tablet', 'mobile'].forEach(viewport => {
                    const status = page[`diff_status_${viewport}`];
                    const diffPct = page[`diff_mismatch_pct_${viewport}`];
                    
                    // Only update if we have actual data (not null/undefined)
                    if (status) {
                        groupedPages[key].viewports[viewport] = {
                            status: status,
                            diff_percentage: diffPct,
                            page_id: page.id
                        };
                    }
                });
                
                // Update other fields if they're more recent or missing
                if (!groupedPages[key].page_name && page.page_name) {
                    groupedPages[key].page_name = page.page_name;
                }
                if (!groupedPages[key].staging_url && page.staging_url) {
                    groupedPages[key].staging_url = page.staging_url;
                }
                if (!groupedPages[key].last_run_at || (page.last_run_at && new Date(page.last_run_at) > new Date(groupedPages[key].last_run_at))) {
                    groupedPages[key].last_run_at = page.last_run_at;
                }
            });
            
            const groupedPagesCount = Object.keys(groupedPages).length;
            console.log(`After grouping: ${groupedPagesCount} unique pages`);
            
            // Create accordion items for each page group
            Object.keys(groupedPages).forEach((pageKey, index) => {
                const pageData = groupedPages[pageKey];
                const accordionId = `accordion-${index}`;
                
                const accordionItem = document.createElement('div');
                accordionItem.className = 'accordion-item';
                
                accordionItem.innerHTML = `
                    <div class="history-page-item">
                        <div class="w-100 d-flex justify-content-between align-items-center py-2 px-3">
                            <div class="page-info-header flex-grow-1">
                                <div class="page-title-compact" style="font-size: 0.875rem; font-weight: 600; color: var(--primary-text); margin-bottom: 0.25rem;">${pageData.page_name || pageData.path || 'Untitled Page'}</div>
                                ${pageData.staging_url ? `<a href="${pageData.staging_url}" target="_blank" class="page-link-compact" style="font-size: 0.75rem; color: var(--accent-color); text-decoration: none; display: block;">${pageData.staging_url} <i class="fas fa-external-link-alt" style="font-size: 0.625rem;"></i></a>` : ''}
                            </div>
                            <div class="viewport-icons-inline">
                                ${generateInlineViewportIcons(pageData, pageKey)}
                            </div>
                        </div>
                    </div>
                `;
                
                accordion.appendChild(accordionItem);
            });
            
            // Add event listeners for both inline viewport icons and viewport buttons
            setTimeout(() => {
                document.querySelectorAll('.viewport-btn, .viewport-icon-inline.clickable').forEach(btn => {
                    btn.addEventListener('click', function(e) {
                        // Prevent accordion from toggling when clicking viewport icons
                        e.stopPropagation();
                        e.preventDefault();
                        
                        const pageId = this.dataset.pageId;
                        const pageName = this.dataset.pageName;
                        const pagePath = this.dataset.pagePath;
                        const viewport = this.dataset.viewport;
                        const diffPct = this.dataset.diffPct;
                        const lastCrawled = this.dataset.lastCrawled;
                        const runId = currentRunData.timestamp;
                        
                        // Ensure we have valid data before opening modal
                        if (pageId && pageName && pagePath && viewport && runId) {
                            openVisualDiffModal(pageId, pageName, pagePath, viewport, diffPct, lastCrawled, runId, true);
                        } else {
                            console.error('Missing required data for viewport click:', {
                                pageId, pageName, pagePath, viewport, runId
                            });
                        }
                    });
                });
            }, 100);
        }
        
        // Generate inline viewport icons for accordion header
        function generateInlineViewportIcons(pageData, pageKey) {
            const viewports = [
                { key: 'desktop', icon: 'fa-desktop', label: 'Desktop', emoji: '<i class="fas fa-desktop"></i>' },
                { key: 'tablet', icon: 'fa-tablet-alt', label: 'Tablet', emoji: '<i class="fas fa-tablet-alt"></i>' },
                { key: 'mobile', icon: 'fa-mobile-alt', label: 'Mobile', emoji: '<i class="fas fa-mobile-alt"></i>' }
            ];
            
            return viewports.map(viewport => {
                const viewportData = pageData.viewports[viewport.key];
                const status = viewportData?.status || 'pending';
                const diffPct = viewportData?.diff_percentage;
                const pageId = viewportData?.page_id;
                
                let diffText = '';
                let diffColor = 'var(--subtle-text)';
                if (status === 'completed' && diffPct !== null && diffPct !== undefined) {
                    diffText = `${Number(diffPct).toFixed(1)}%`;
                    diffColor = diffPct > 5 ? 'var(--danger-color)' : diffPct > 1 ? 'var(--warning-color)' : 'var(--success-color)';
                } else if (status === 'failed') {
                    diffText = '!';
                    diffColor = 'var(--danger-color)';
                } else if (status === 'no_baseline') {
                    diffText = '?';
                    diffColor = 'var(--warning-color)';
                } else {
                    diffText = '-';
                    diffColor = 'var(--subtle-text)';
                }
                
                const isClickable = true; // Always make clickable to allow viewing any available images
                const buttonClass = 'viewport-icon-inline clickable';
                const cursor = 'cursor: pointer;';
                
                return `
                    <div class="${buttonClass}"
                         style="${cursor} display: flex; flex-direction: column; align-items: center; padding: 0.25rem; min-width: 35px;"
                         title="${viewport.label} - Click to view images"
                         data-page-id="${pageId || ''}"
                         data-page-name="${pageData.page_name || pageData.path || 'Untitled Page'}"
                         data-page-path="${pageData.path || '/'}"
                         data-viewport="${viewport.key}"
                         data-diff-pct="${diffPct || 0}"
                         data-last-crawled="${pageData.last_run_at || ''}">
                        <span class="viewport-emoji" style="font-size: 1.1rem; margin-bottom: 0.125rem;">${viewport.emoji}</span>
                        <small style="color: ${diffColor}; font-weight: 600; font-size: 0.625rem;">${diffText}</small>
                    </div>
                `;
            }).join('');
        }
        
        // Format timestamp to required format (13/08 11:51 PM)
        function formatTimestamp(timestamp) {
            if (!timestamp) {
                return 'Never crawled';
            }
            
            try {
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) {
                    return 'Invalid date';
                }
                
                // Format as DD/MM HH:MM AM/PM
                const day = date.getDate().toString().padStart(2, '0');
                const month = (date.getMonth() + 1).toString().padStart(2, '0');
                const hours = date.getHours();
                const minutes = date.getMinutes().toString().padStart(2, '0');
                const ampm = hours >= 12 ? 'PM' : 'AM';
                const displayHours = hours % 12 || 12;
                
                return `${day}/${month} ${displayHours}:${minutes} ${ampm}`;
            } catch (error) {
                console.error('Error formatting timestamp:', error);
                return 'Invalid date';
            }
        }
        
        // Generate viewport buttons for a page (kept for backward compatibility)
        function generateViewportButtons(pageData, pageKey) {
            const viewports = [
                { key: 'desktop', icon: 'fa-desktop', label: 'Desktop' },
                { key: 'tablet', icon: 'fa-tablet-alt', label: 'Tablet' },
                { key: 'mobile', icon: 'fa-mobile-alt', label: 'Mobile' }
            ];
            
            return viewports.map(viewport => {
                const viewportData = pageData.viewports[viewport.key];
                const status = viewportData?.status || 'pending';
                const diffPct = viewportData?.diff_percentage;
                const pageId = viewportData?.page_id;
                
                let diffBadge = '';
                if (status === 'completed' && diffPct !== null && diffPct !== undefined) {
                    const badgeClass = diffPct > 5 ? 'bg-danger' : diffPct > 1 ? 'bg-warning' : 'bg-success';
                    diffBadge = `<span class="badge ${badgeClass} diff-badge">${Number(diffPct).toFixed(1)}%</span>`;
                } else if (status === 'failed') {
                    diffBadge = '<span class="badge bg-danger diff-badge">!</span>';
                } else if (status === 'no_baseline') {
                    diffBadge = '<span class="badge bg-warning diff-badge">?</span>';
                }
                
                const isClickable = status === 'completed';
                const buttonClass = isClickable ? 'viewport-btn' : 'viewport-btn disabled';
                const cursor = isClickable ? 'cursor: pointer;' : 'cursor: not-allowed; opacity: 0.5;';
                
                return `
                    <div class="${buttonClass}"
                         style="${cursor}"
                         ${isClickable ? `
                         data-page-id="${pageId || ''}"
                         data-page-name="${pageData.page_name || pageData.path || 'Untitled Page'}"
                         data-page-path="${pageData.path || '/'}"
                         data-viewport="${viewport.key}"
                         data-diff-pct="${diffPct || 0}"
                         data-last-crawled="${pageData.last_run_at || ''}"
                         ` : ''}>
                        <i class="fas ${viewport.icon}"></i>
                        <div class="viewport-label">${viewport.label}</div>
                        ${diffBadge}
                    </div>
                `;
            }).join('');
        }

        // Screenshot Modal Functions
        function openScreenshotModal(pageId, pageName, pagePath, viewport, runId) {
            // Set modal title
            document.getElementById('screenshotPageTitle').textContent = pageName;
            document.getElementById('screenshotPagePath').textContent = pagePath;
            
            // Generate image URLs using the new asset resolver route
            // Convert page path to canonical slug format
            const pageSlug = pagePath.replace(/\//g, 'home').replace(/[\\]/g, '_').replace(/_/g, '-').toLowerCase();
            const stagingUrl = `/assets/runs/${currentProjectId}/${runId}/${viewport}/${pageSlug}-staging.png`;
            const productionUrl = `/assets/runs/${currentProjectId}/${runId}/${viewport}/${pageSlug}-production.png`;
            const diffUrl = `/assets/runs/${currentProjectId}/${runId}/${viewport}/${pageSlug}-diff.png`;
            
            // Set image sources with error handling
            setImageWithFallback('stagingImage', stagingUrl, 'Staging screenshot not available');
            setImageWithFallback('productionImage', productionUrl, 'Production screenshot not available');
            setImageWithFallback('diffImage', diffUrl, 'Diff image not available');
            setImageWithFallback('overlayBaseImage', stagingUrl, 'Staging screenshot not available');
            setImageWithFallback('overlayTopImage', productionUrl, 'Production screenshot not available');
            setImageWithFallback('diffOnlyImage', diffUrl, 'Diff image not available');
            
            // Reset view mode to side-by-side
            document.getElementById('sideBySide').checked = true;
            switchViewMode('side-by-side');
            
            // Show the modal with proper configuration
            const modal = new bootstrap.Modal(document.getElementById('screenshotModal'), {
                backdrop: 'static',
                keyboard: false
            });
            modal.show();
        }

        // Helper function to set image with fallback handling
        function setImageWithFallback(elementId, imageUrl, fallbackText) {
            const img = document.getElementById(elementId);
            if (!img) {
                console.warn(` Image element not found: ${elementId}`);
                return;
            }
            
            console.log(` Setting image for ${elementId}: ${imageUrl}`);
            
            // Clear any existing fallback
            const existingFallback = img.parentNode.querySelector('.image-fallback');
            if (existingFallback) {
                existingFallback.remove();
            }
            
            // Create a new image to test if it loads
            const testImg = new Image();
            testImg.onload = function() {
                // Image loaded successfully
                console.log(` Image loaded successfully for ${elementId}: ${imageUrl}`);
                img.src = imageUrl;
                img.style.display = 'block';
                img.alt = '';
                
                // Hide any existing fallback
                const fallbackDiv = img.parentNode.querySelector('.image-fallback');
                if (fallbackDiv) {
                    fallbackDiv.style.display = 'none';
                }
            };
            testImg.onerror = function() {
                // Image failed to load, show fallback
                console.warn(` Image failed to load for ${elementId}: ${imageUrl}`);
                img.style.display = 'none';
                
                // Create or update fallback div
                let fallbackDiv = img.parentNode.querySelector('.image-fallback');
                if (!fallbackDiv) {
                    fallbackDiv = document.createElement('div');
                    fallbackDiv.className = 'image-fallback';
                    fallbackDiv.style.cssText = `
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        min-height: 300px;
                        background-color: #f8f9fa;
                        border: 2px dashed #dee2e6;
                        color: #6c757d;
                        font-size: 14px;
                        text-align: center;
                        border-radius: 4px;
                        margin: 1rem;
                        flex-direction: column;
                        gap: 0.5rem;
                    `;
                    img.parentNode.appendChild(fallbackDiv);
                }
                
                // Create fallback content with icon and text
                fallbackDiv.innerHTML = `
                    <i class="fas fa-image" style="font-size: 2rem; opacity: 0.5;"></i>
                    <div>${fallbackText}</div>
                    <small style="opacity: 0.7;">URL: ${imageUrl}</small>
                `;
                fallbackDiv.style.display = 'flex';
            };
            
            // Add cache busting parameter to ensure fresh load
            const cacheBustUrl = imageUrl + (imageUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
            testImg.src = cacheBustUrl;
        }

        // View mode switching
        document.querySelectorAll('input[name="viewMode"]').forEach(radio => {
            radio.addEventListener('change', function() {
                switchViewMode(this.value);
            });
        });

        // Visual Diff Modal Functions
        function openVisualDiffModal(pageId, pageName, pagePath, viewport, diffPct, lastCrawled, runId, showDiffOnly = true) {
    console.log(' openVisualDiffModal called with:', {
        pageId, pageName, pagePath, viewport, diffPct, lastCrawled, runId, showDiffOnly
    });
    
    try {
        // Check if modal exists
        const modalElement = document.getElementById('visualDiffModal');
        if (!modalElement) {
            console.error(' Visual diff modal element not found');
            showToast('error', 'Visual diff modal not available. Please refresh the page.');
            return;
        }
        
        console.log(' Modal element found:', modalElement);
        
        // Set modal title and info with null checks
        const titleElement = document.getElementById('diffPageTitle');
        const pathElement = document.getElementById('diffPagePath');
        
        if (titleElement) {
            titleElement.textContent = pageName || 'Unknown Page';
        } else {
            console.warn(' diffPageTitle element not found');
        }
        
        if (pathElement) {
            pathElement.textContent = pagePath || '/';
        } else {
            console.warn(' diffPagePath element not found');
        }
        
        console.log(' Set modal title to:', pageName);
        console.log(' Set modal path to:', pagePath);
        
        // Set viewport icon and label with null checks
        const viewportIcon = document.getElementById('diffViewportIcon');
        const viewportLabel = document.getElementById('diffViewportLabel');
        
        if (viewportIcon && viewportLabel) {
            if (viewport === 'desktop') {
                viewportIcon.innerHTML = '<i class="fas fa-desktop"></i>';
                viewportLabel.textContent = 'Desktop';
            } else if (viewport === 'tablet') {
                viewportIcon.innerHTML = '<i class="fas fa-tablet-alt"></i>';
                viewportLabel.textContent = 'Tablet';
            } else if (viewport === 'mobile') {
                viewportIcon.innerHTML = '<i class="fas fa-mobile-alt"></i>';
                viewportLabel.textContent = 'Mobile';
            }
        } else {
            console.warn(' Viewport icon or label elements not found');
        }
        
        // Set diff percentage with null checks
        const diffPercentage = document.getElementById('diffPercentage');
        if (diffPercentage) {
            if (diffPct !== null && diffPct !== undefined && diffPct > 0) {
                const badgeClass = diffPct > 5 ? 'bg-danger' : diffPct > 1 ? 'bg-warning' : 'bg-success';
                diffPercentage.innerHTML = `<span class="badge ${badgeClass}">${parseFloat(diffPct).toFixed(1)}%</span>`;
            } else {
                diffPercentage.innerHTML = '<span class="badge bg-secondary">0.0%</span>';
            }
        } else {
            console.warn(' diffPercentage element not found');
        }
        
        // Set last crawled time with null checks
        const lastCrawledElement = document.getElementById('diffLastCrawled');
        if (lastCrawledElement) {
            if (lastCrawled) {
                try {
                    const crawledDate = new Date(lastCrawled);
                    lastCrawledElement.textContent = crawledDate.toLocaleString();
                } catch (dateError) {
                    console.warn(' Invalid date format:', lastCrawled);
                    lastCrawledElement.textContent = 'Invalid date';
                }
            } else {
                lastCrawledElement.textContent = 'Never';
            }
        } else {
            console.warn(' diffLastCrawled element not found');
        }
        
        // Generate proper page slug for asset resolver
        // Convert path to canonical slug format expected by asset resolver
        let pageSlug = pagePath || '/';
        
        // Handle root path
        if (pageSlug === '/' || pageSlug === '') {
            pageSlug = 'home';
        } else {
            // Remove leading/trailing slashes and convert to slug
            pageSlug = pageSlug.replace(/^\/+|\/+$/g, '');
            // Replace slashes with dashes and normalize
            pageSlug = pageSlug.replace(/\//g, '-').replace(/[^a-z0-9\-]/gi, '-').replace(/-+/g, '-').toLowerCase();
            // Remove leading/trailing dashes
            pageSlug = pageSlug.replace(/^-+|-+$/g, '');
            // If empty after processing, use home
            if (!pageSlug) {
                pageSlug = 'home';
            }
        }
        
        // Handle "latest" run ID for main table clicks
        let actualRunId = runId;
        if (runId === 'latest' || runId === 'current' || !runId) {
            // For main table clicks, use current timestamp or a default recent run
            // We'll use a placeholder that the asset resolver can handle
            actualRunId = 'current';
        }
        
        // Generate image URLs using the correct asset resolver route format
        const diffUrl = `/assets/runs/${currentProjectId}/${actualRunId}/${viewport}/${pageSlug}-diff.png`;
        const productionUrl = `/assets/runs/${currentProjectId}/${actualRunId}/${viewport}/${pageSlug}-production.png`;
        const stagingUrl = `/assets/runs/${currentProjectId}/${actualRunId}/${viewport}/${pageSlug}-staging.png`;
        
        console.log(' Generated image URLs:', {
            pageSlug, diffUrl, productionUrl, stagingUrl
        });
        
        // For viewport icon clicks, prioritize showing the diff image
        if (showDiffOnly) {
            // Only load the diff image for viewport icon clicks
            console.log(' Loading only diff image for viewport icon click:', diffUrl);
            setImageWithFallback('diffOnlyImage', diffUrl, 'Difference image not available');
            setImageWithFallback('diffDifferenceSide', diffUrl, 'Difference image not available');
            
            // Do NOT load staging and production images to avoid unnecessary fetches
            console.log(' Skipping staging and production image loads for diff-only view');
        } else {
            // Set all images for side-by-side view
            console.log(' Loading all images for side-by-side view');
            setImageWithFallback('diffProductionSide', productionUrl, 'Production screenshot not available');
            setImageWithFallback('diffStagingSide', stagingUrl, 'Staging screenshot not available');
            setImageWithFallback('diffDifferenceSide', diffUrl, 'Difference image not available');
            setImageWithFallback('diffOnlyImage', diffUrl, 'Difference image not available');
        }
        
        // Set view mode based on showDiffOnly parameter
        const sideBySideModeElement = document.getElementById('sideBySideMode');
        const diffOnlyModeElement = document.getElementById('diffOnlyMode');
        
        if (showDiffOnly && diffOnlyModeElement) {
            // Default to "Diff Only" view when clicked from viewport icons
            diffOnlyModeElement.checked = true;
            switchDiffViewMode('diff-only');
            console.log('Set to Diff Only view for viewport icon click');
        } else if (sideBySideModeElement) {
            // Default to "Side by Side" view for other cases
            sideBySideModeElement.checked = true;
            switchDiffViewMode('side-by-side');
            console.log('Set to Side by Side view');
        } else {
            console.warn(' View mode elements not found');
        }
        
        // Store URLs for expand functionality
        window.currentDiffImages = {
            production: productionUrl,
            staging: stagingUrl,
            difference: diffUrl
        };
        
        // Show the modal with proper configuration
        console.log(' Creating and showing visual diff modal...');
        
        const modal = new bootstrap.Modal(modalElement, {
            backdrop: 'static',
            keyboard: false
        });
        console.log(' Bootstrap modal created:', modal);
        
        modal.show();
        console.log(' Modal show() called');
        
    } catch (error) {
        console.error(' Error in openVisualDiffModal:', error);
        showToast('error', 'Error opening visual diff modal: ' + error.message);
    }
}
        
        // Expand image function for visual diff modal
        function expandImage(imageType) {
            if (!window.currentDiffImages) return;
            
            const imageUrl = window.currentDiffImages[imageType];
            if (!imageUrl) return;
            
            // Open the existing screenshot modal with the expanded image
            const pageName = document.getElementById('diffPageTitle').textContent;
            const pagePath = document.getElementById('diffPagePath').textContent;
            
            // Set modal title
            document.getElementById('screenshotPageTitle').textContent = pageName;
            document.getElementById('screenshotPagePath').textContent = pagePath;
            
            // Set all images to the same expanded image for simplicity
            setImageWithFallback('stagingImage', imageUrl, `${imageType} screenshot not available`);
            setImageWithFallback('productionImage', imageUrl, `${imageType} screenshot not available`);
            setImageWithFallback('diffImage', imageUrl, `${imageType} screenshot not available`);
            setImageWithFallback('overlayBaseImage', imageUrl, `${imageType} screenshot not available`);
            setImageWithFallback('overlayTopImage', imageUrl, `${imageType} screenshot not available`);
            setImageWithFallback('diffOnlyImage', imageUrl, `${imageType} screenshot not available`);
            
// Switch between diff view modes
        function switchDiffViewMode(mode) {
            // Hide all view modes
            document.querySelectorAll('.diff-view-mode').forEach(view => {
                view.style.display = 'none';
            });
            
            // Show selected view mode
            switch(mode) {
                case 'side-by-side':
                    document.getElementById('sideBySideViewDiff').style.display = 'block';
                    break;
                case 'diff-only':
                    document.getElementById('diffOnlyViewDiff').style.display = 'block';
                    break;
            }
        }
        
        // Add event listeners for diff view mode toggle
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('input[name="diffViewMode"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    switchDiffViewMode(this.value);
                });
            });
        });
            // Hide the visual diff modal first
            const visualDiffModal = bootstrap.Modal.getInstance(document.getElementById('visualDiffModal'));
            if (visualDiffModal) {
                visualDiffModal.hide();
            }
            
            // Show the screenshot modal after a brief delay
            setTimeout(() => {
                // Reset view mode to diff-only for expanded view
                document.getElementById('diffOnly').checked = true;
                switchViewMode('diff-only');
                
                const modal = new bootstrap.Modal(document.getElementById('screenshotModal'), {
                    backdrop: 'static',
                    keyboard: false
                });
                modal.show();
            }, 300);
        }

        // Switch between diff view modes
        function switchDiffViewMode(mode) {
            // Hide all view modes
            document.querySelectorAll('.diff-view-mode').forEach(view => {
                view.style.display = 'none';
            });
            
            // Show selected view mode
            switch(mode) {
                case 'side-by-side':
                    document.getElementById('sideBySideViewDiff').style.display = 'block';
                    break;
                case 'thumbnails':
                    document.getElementById('thumbnailsViewDiff').style.display = 'block';
                    break;
            }
        }
        
        // Add event listeners for diff view mode toggle
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('input[name="diffViewMode"]').forEach(radio => {
                radio.addEventListener('change', function() {
                    switchDiffViewMode(this.value);
                });
            });
        });

        function switchViewMode(mode) {
            // Hide all view modes
            document.querySelectorAll('.view-mode').forEach(view => {
                view.style.display = 'none';
            });
            
            // Show selected view mode
            switch(mode) {
                case 'side-by-side':
                    document.getElementById('sideBySideView').style.display = 'block';
                    break;
                case 'overlay':
                    document.getElementById('overlayView').style.display = 'block';
                    break;
                case 'diff-only':
                    document.getElementById('diffOnlyView').style.display = 'block';
                    break;
            }
        }

        // Opacity slider for overlay mode
        document.getElementById('opacitySlider').addEventListener('input', function() {
            const opacity = this.value / 100;
            document.getElementById('overlayTopImage').style.opacity = opacity;
        });

        // Image zoom functionality
        document.querySelectorAll('.screenshot-image').forEach(img => {
            img.addEventListener('click', function() {
                if (this.style.transform === 'scale(2)') {
                    this.style.transform = 'scale(1)';
                    this.style.cursor = 'zoom-in';
                } else {
                    this.style.transform = 'scale(2)';
                    this.style.cursor = 'zoom-out';
                }
            });
        });

        // Helper functions for showing/hiding elements
        function showHistoryLoading() {
            document.getElementById('historyLoading').style.display = 'block';
            document.getElementById('historyAccordionContainer').style.display = 'none';
            document.getElementById('historyEmpty').style.display = 'none';
        }

        function hideHistoryLoading() {
            document.getElementById('historyLoading').style.display = 'none';
        }

        function showHistoryTable() {
            document.getElementById('historyAccordionContainer').style.display = 'block';
            document.getElementById('historyEmpty').style.display = 'none';
        }

        function hideHistoryTable() {
            document.getElementById('historyAccordionContainer').style.display = 'none';
        }

        function showHistoryEmpty() {
            document.getElementById('historyEmpty').style.display = 'block';
            document.getElementById('historyAccordionContainer').style.display = 'none';
            document.getElementById('historyPagination').style.display = 'none';
        }

        // Update pagination controls
        function updatePaginationControls(pagination) {
            console.log(` updatePaginationControls called with:`, pagination);
            
            const paginationElement = document.getElementById('historyPagination');
            const paginationInfoElement = document.getElementById('paginationInfo');
            const historyPerPageElement = document.getElementById('historyPerPage');
            
            if (!pagination) {
                console.log(` Hiding pagination - no pagination object`);
                paginationElement.style.display = 'none';
                return;
            }

            // Always show pagination controls if we have pagination data, even for single page
            console.log(` Showing pagination controls - ${pagination.pages || 1} total pages, ${pagination.total || 0} total items`);
            paginationElement.style.display = 'flex';
            
            // Update pagination info
            const start = pagination.total > 0 ? ((pagination.page - 1) * pagination.per_page) + 1 : 0;
            const end = Math.min(pagination.page * pagination.per_page, pagination.total);
            const infoText = `Showing ${start} to ${end} of ${pagination.total} entries`;
            
            console.log(` Pagination info: ${infoText}`);
            paginationInfoElement.textContent = infoText;
            
            // Update per page selector
            historyPerPageElement.value = pagination.per_page;
            console.log(` Set per page selector to: ${pagination.per_page}`);
            
            // Generate pagination buttons only if more than 1 page
            if (pagination.pages > 1) {
                generatePaginationButtons(pagination);
            } else {
                // Hide pagination buttons but keep info visible
                const nav = document.getElementById('historyPaginationNav');
                nav.innerHTML = '';
            }
        }

        // Generate pagination buttons
        function generatePaginationButtons(pagination) {
            console.log(` generatePaginationButtons called with:`, pagination);
            
            const nav = document.getElementById('historyPaginationNav');
            nav.innerHTML = '';
            
            // Previous button
            const prevLi = document.createElement('li');
            prevLi.className = `page-item ${!pagination.has_prev ? 'disabled' : ''}`;
            
            if (pagination.has_prev) {
                prevLi.innerHTML = `
                    <a class="page-link" href="#" onclick="changePage(${pagination.prev_num}); return false;">
                        <i class="fas fa-chevron-left"></i>
                    </a>
                `;
            } else {
                prevLi.innerHTML = `
                    <span class="page-link" tabindex="-1">
                        <i class="fas fa-chevron-left"></i>
                    </span>
                `;
            }
            nav.appendChild(prevLi);
            
            // Page numbers
            const startPage = Math.max(1, pagination.page - 2);
            const endPage = Math.min(pagination.pages, pagination.page + 2);
            
            console.log(` Generating page buttons from ${startPage} to ${endPage}, current page: ${pagination.page}`);
            
            for (let i = startPage; i <= endPage; i++) {
                const pageLi = document.createElement('li');
                pageLi.className = `page-item ${i === pagination.page ? 'active' : ''}`;
                
                if (i === pagination.page) {
                    pageLi.innerHTML = `<span class="page-link">${i}</span>`;
                } else {
                    pageLi.innerHTML = `
                        <a class="page-link" href="#" onclick="changePage(${i}); return false;">${i}</a>
                    `;
                }
                nav.appendChild(pageLi);
            }
            
            // Next button
            const nextLi = document.createElement('li');
            nextLi.className = `page-item ${!pagination.has_next ? 'disabled' : ''}`;
            
            if (pagination.has_next) {
                nextLi.innerHTML = `
                    <a class="page-link" href="#" onclick="changePage(${pagination.next_num}); return false;">
                        <i class="fas fa-chevron-right"></i>
                    </a>
                `;
            } else {
                nextLi.innerHTML = `
                    <span class="page-link" tabindex="-1">
                        <i class="fas fa-chevron-right"></i>
                    </span>
                `;
            }
            nav.appendChild(nextLi);
            
            console.log(` Generated ${nav.children.length} pagination buttons`);
        }

        // Change page function
        function changePage(page) {
            console.log(` changePage called with page: ${page}, currentRunData:`, currentRunData);
            
            if (page && currentRunData && currentRunData.timestamp) {
                console.log(` Loading page ${page} with ${currentPerPage} items per page`);
                loadHistoryPages(currentRunData.timestamp, page, currentPerPage);
            } else {
                console.error(' Cannot change page - missing data:', { page, currentRunData, currentPerPage });
            }
            return false;
        }

        // Change per page function
        function changePerPage() {
            const perPage = parseInt(document.getElementById('historyPerPage').value);
            console.log(` changePerPage called with perPage: ${perPage}, currentRunData:`, currentRunData);
            
            if (currentRunData && currentRunData.timestamp) {
                console.log(` Changing to ${perPage} items per page, resetting to page 1`);
                loadHistoryPages(currentRunData.timestamp, 1, perPage);
            } else {
                console.error(' Cannot change per page - missing currentRunData:', currentRunData);
            }
        }

        // History Modal functionality for project details page
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listeners for history buttons
            document.querySelectorAll('.history-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const projectId = this.dataset.projectId;
                    const projectName = this.dataset.projectName;
                    openHistoryModalFromDetails(projectId, projectName);
                });
            });
            
            // Add event listener for per page selector
            document.getElementById('historyPerPage').addEventListener('change', changePerPage);
        });

        // Open History Modal from project details
        function openHistoryModalFromDetails(projectId, projectName) {
            currentProjectId = parseInt(projectId);
            
            document.getElementById('historyModalLabel').innerHTML =
                `<i class="fas fa-history me-2"></i>Project History - ${projectName}`;
            
            // Show modal with proper configuration
            const modal = new bootstrap.Modal(document.getElementById('historyModal'), {
                backdrop: 'static',
                keyboard: false
            });
            modal.show();
            
            // Load runs
            loadHistoryRuns();
        }

        // Project Details Page - Process Run Functionality
        var currentProjectDetailsId = parseInt('{{ project.id }}');
        var currentSelectedRun = null;
        var currentSelectedRunData = null;

        // Load process runs when page loads
        document.addEventListener('DOMContentLoaded', function() {
            loadProcessRuns();
            
            // Add event listener for process run selector
            document.getElementById('processRunSelector').addEventListener('change', onProcessRunSelected);
        });

        // Load available process runs for the project
        function loadProcessRuns() {
            const runSelector = document.getElementById('processRunSelector');
            runSelector.innerHTML = '<option value="">Loading runs...</option>';
            
            fetch(`/api/history/project/${currentProjectDetailsId}/runs`)
                .then(response => response.json())
                .then(data => {
                    runSelector.innerHTML = '';
                    
                    if (data.success && data.runs && data.runs.length > 0) {
                        // Add default option
                        runSelector.innerHTML = '<option value="">Select a process run...</option>';
                        
                        // Add runs in reverse chronological order (newest first)
                        data.runs.forEach(run => {
                            const option = document.createElement('option');
                            option.value = run.timestamp;  // Use timestamp as value
                            option.textContent = `${run.datetime} (${run.page_count} pages)`;
                            option.dataset.runData = JSON.stringify({
                                run_id: run.timestamp,
                                formatted_date: run.datetime,
                                pages_count: run.page_count,
                                timestamp: run.timestamp
                            });
                            runSelector.appendChild(option);
                        });
                        
                        // Auto-select the most recent run
                        if (data.runs.length > 0) {
                            runSelector.value = data.runs[0].timestamp;
                            onProcessRunSelected();
                        }
                    } else {
                        runSelector.innerHTML = '<option value="">No runs available</option>';
                        showPagesEmpty();
                    }
                })
                .catch(error => {
                    console.error('Error loading runs:', error);
                    runSelector.innerHTML = '<option value="">Error loading runs</option>';
                    showPagesEmpty();
                });
        }

        // Handle process run selection change
        function onProcessRunSelected() {
            const runSelector = document.getElementById('processRunSelector');
            const selectedOption = runSelector.options[runSelector.selectedIndex];
            
            if (!selectedOption.value) {
                hidePagesTable();
                showPagesEmpty();
                return;
            }
            
            // Get run data from option dataset
            try {
                currentSelectedRunData = JSON.parse(selectedOption.dataset.runData);
                currentSelectedRun = currentSelectedRunData.run_id;
                
                // Update run info
                updateProcessRunInfo(currentSelectedRunData);
                
                // Load pages for selected run
                loadProcessRunPages(currentSelectedRun);
            } catch (error) {
                console.error('Error parsing run data:', error);
                showPagesEmpty();
            }
        }

        // Update process run information display
        function updateProcessRunInfo(runData) {
            const runInfo = document.getElementById('processRunInfo');
            const runDetails = document.getElementById('processRunDetails');
            
            runDetails.innerHTML = `
                ${runData.pages_count} pages |
                Started: ${runData.formatted_date}
            `;
            
            runInfo.style.display = 'block';
        }

        // Load pages for selected process run
        function loadProcessRunPages(runId) {
            showPagesLoading();
            
            const url = `/api/history/project/${currentProjectDetailsId}/run/${runId}/pages`;
            
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    hidePagesLoading();
                    
                    if (data.success && data.pages) {
                        populatePagesAccordion(data.pages);
                        updatePageCount(data.pages.length);
                        showPagesTable();
                    } else {
                        showPagesEmpty();
                    }
                })
                .catch(error => {
                    console.error('Error loading pages:', error);
                    hidePagesLoading();
                    showPagesEmpty();
                });
        }

        // Populate the pages accordion with grouped page data
        function populatePagesAccordion(pages) {
            const accordion = document.getElementById('pagesAccordion');
            accordion.innerHTML = '';
            accordion.className = 'accordion';
            
            // Group pages by page name/path
            const groupedPages = {};
            pages.forEach(page => {
                const key = page.page_name || page.path;
                if (!groupedPages[key]) {
                    groupedPages[key] = {
                        page_name: page.page_name,
                        path: page.path,
                        last_run_at: page.last_run_at,
                        viewports: {}
                    };
                }
                
                // Add viewport data
                ['desktop', 'tablet', 'mobile'].forEach(viewport => {
                    const status = page[`diff_status_${viewport}`];
                    const diffPct = page[`diff_mismatch_pct_${viewport}`];
                    
                    groupedPages[key].viewports[viewport] = {
                        status: status,
                        diff_percentage: diffPct,
                        page_id: page.id
                    };
                });
            });
            
            // Create accordion items for each page group
            Object.keys(groupedPages).forEach((pageKey, index) => {
                const pageData = groupedPages[pageKey];
                const accordionId = `pages-accordion-${index}`;
                
                const accordionItem = document.createElement('div');
                accordionItem.className = 'accordion-item';
                
                accordionItem.innerHTML = `
                    <div class="history-page-item">
                        <div class="w-100 d-flex justify-content-between align-items-center p-3">
                            <div class="page-info-header">
                                <div class="page-title-large">${pageData.page_name || pageData.path || 'Untitled Page'}</div>
                                <div class="page-path-large">${pageData.path || '/'}</div>
                                <div class="page-stats">
                                    <div class="page-stat">
                                        <i class="fas fa-clock"></i>
                                        <span>${formatTimestamp(pageData.last_run_at)}</span>
                                    </div>
                                </div>
                            </div>
                            <div class="viewport-icons-inline">
                                ${generateInlineViewportIconsForPages(pageData, pageKey)}
                            </div>
                        </div>
                    </div>
                `;
                
                accordion.appendChild(accordionItem);
            });
            
            // Add event listeners for viewport icons after DOM is updated
            setTimeout(() => {
                const clickableIcons = document.querySelectorAll('#pagesAccordion .viewport-icon-inline.clickable');
                console.log('Found clickable viewport icons in pages:', clickableIcons.length);
                
                clickableIcons.forEach((btn, index) => {
                    console.log(`Attaching listener to pages icon ${index}:`, btn);
                    btn.addEventListener('click', function(e) {
                        e.stopPropagation();
                        e.preventDefault();
                        
                        console.log('Pages viewport icon clicked! Element:', this);
                        
                        const pageId = this.dataset.pageId;
                        const pageName = this.dataset.pageName;
                        const pagePath = this.dataset.pagePath;
                        const viewport = this.dataset.viewport;
                        const diffPct = this.dataset.diffPct;
                        const lastCrawled = this.dataset.lastCrawled;
                        const runId = currentSelectedRun;
                        
                        console.log('Pages viewport icon clicked with data:', {
                            pageId, pageName, pagePath, viewport, runId, diffPct, lastCrawled
                        });
                        
                        // Ensure we have valid data before opening modal
                        if (pageId && pageName && pagePath && viewport && runId) {
                            openVisualDiffModal(pageId, pageName, pagePath, viewport, diffPct, lastCrawled, runId, true);
                        } else {
                            console.error('Missing required data for pages viewport click:', {
                                pageId, pageName, pagePath, viewport, runId
                            });
                        }
                    });
                });
            }, 100);
        }
        
        // Generate inline viewport icons for pages accordion (similar to history but for main page)
        function generateInlineViewportIconsForPages(pageData, pageKey) {
            const viewports = [
                { key: 'desktop', icon: 'fa-desktop', label: 'Desktop', emoji: '<i class="fas fa-desktop"></i>' },
                { key: 'tablet', icon: 'fa-tablet-alt', label: 'Tablet', emoji: '<i class="fas fa-tablet-alt"></i>' },
                { key: 'mobile', icon: 'fa-mobile-alt', label: 'Mobile', emoji: '<i class="fas fa-mobile-alt"></i>' }
            ];
            
            console.log('generateInlineViewportIconsForPages called with:', { pageData, pageKey });
            
            return viewports.map(viewport => {
                const viewportData = pageData.viewports[viewport.key];
                const status = viewportData?.status || 'pending';
                const diffPct = viewportData?.diff_percentage;
                const pageId = viewportData?.page_id;
                
                console.log(`Pages Viewport ${viewport.key}:`, { viewportData, status, diffPct, pageId });
                
                let diffBadge = '';
                if (status === 'completed' && diffPct !== null && diffPct !== undefined) {
                    const badgeClass = diffPct > 5 ? 'bg-danger' : diffPct > 1 ? 'bg-warning' : 'bg-success';
                    diffBadge = `<span class="badge ${badgeClass} diff-badge-inline">${Number(diffPct).toFixed(1)}%</span>`;
                } else if (status === 'failed') {
                    diffBadge = '<span class="badge bg-danger diff-badge-inline">!</span>';
                } else if (status === 'no_baseline') {
                    diffBadge = '<span class="badge bg-warning diff-badge-inline">?</span>';
                } else {
                    diffBadge = '<span class="badge bg-secondary diff-badge-inline">-</span>';
                }
                
                const isClickable = status === 'completed';
                const buttonClass = isClickable ? 'viewport-icon-inline clickable' : 'viewport-icon-inline disabled';
                const cursor = isClickable ? 'cursor: pointer;' : 'cursor: not-allowed; opacity: 0.6;';
                
                return `
                    <div class="${buttonClass}"
                         style="${cursor}"
                         title="${viewport.label} - ${status === 'completed' ? 'Click to view diff' : status}"
                         ${isClickable ? `
                         data-page-id="${pageId || ''}"
                         data-page-name="${pageData.page_name || pageData.path || 'Untitled Page'}"
                         data-page-path="${pageData.path || '/'}"
                         data-viewport="${viewport.key}"
                         data-diff-pct="${diffPct || 0}"
                         data-last-crawled="${pageData.last_run_at || ''}"
                         ` : ''}>
                        <span class="viewport-emoji">${viewport.emoji}</span>
                        ${diffBadge}
                    </div>
                `;
            }).join('');
        }

        // Update page count display
        function updatePageCount(count) {
            document.getElementById('pageCount').textContent = count;
        }

        // Helper functions for showing/hiding pages elements
        function showPagesLoading() {
            document.getElementById('pagesLoading').style.display = 'block';
            document.getElementById('pagesAccordionContainer').style.display = 'none';
            document.getElementById('pagesEmpty').style.display = 'none';
        }

        function hidePagesLoading() {
            document.getElementById('pagesLoading').style.display = 'none';
        }

        function showPagesTable() {
            document.getElementById('pagesAccordionContainer').style.display = 'block';
            document.getElementById('pagesEmpty').style.display = 'none';
        }

        function hidePagesTable() {
            document.getElementById('pagesAccordionContainer').style.display = 'none';
        }

        function showPagesEmpty() {
            document.getElementById('pagesEmpty').style.display = 'block';
            document.getElementById('pagesAccordionContainer').style.display = 'none';
            updatePageCount(0);
        }

        // Filter functionality for discovered pages table
        document.addEventListener('DOMContentLoaded', function() {
            const pageSearch = document.getElementById('pageSearch');
            const statusFilter = document.getElementById('statusFilter');
            const perPageFilter = document.getElementById('perPageFilter');
            const applyFiltersBtn = document.getElementById('applyFilters');
            const clearFiltersBtn = document.getElementById('clearFilters');
            
            // Store original table rows
            const tableBody = document.querySelector('.modern-table tbody');
            const originalRows = Array.from(tableBody.querySelectorAll('tr'));
            let filteredRows = [...originalRows];
            let currentPage = 1;
            let rowsPerPage = 10;
            
            // Apply filters function
            function applyFilters() {
                const searchTerm = pageSearch.value.toLowerCase().trim();
                const selectedStatus = statusFilter.value;
                rowsPerPage = parseInt(perPageFilter.value);
                
                // Filter rows based on criteria
                filteredRows = originalRows.filter(row => {
                    // Search filter (page name, path, and URLs)
                    const pageCell = row.cells[0];
                    const stagingUrlCell = row.cells[1];
                    const productionUrlCell = row.cells[2];
                    
                    const pageName = pageCell.querySelector('.page-title')?.textContent.toLowerCase() || '';
                    const pagePath = pageCell.querySelector('.page-path code')?.textContent.toLowerCase() || '';
                    const stagingUrl = stagingUrlCell.textContent.toLowerCase() || '';
                    const productionUrl = productionUrlCell.textContent.toLowerCase() || '';
                    
                    const matchesSearch = !searchTerm ||
                        pageName.includes(searchTerm) ||
                        pagePath.includes(searchTerm) ||
                        stagingUrl.includes(searchTerm) ||
                        productionUrl.includes(searchTerm);
                    
                    // Status filter
                    const statusCell = row.cells[3];
                    const statusText = statusCell.textContent.toLowerCase();
                    let matchesStatus = true;
                    if (selectedStatus) {
                        switch(selectedStatus) {
                            case 'completed':
                                matchesStatus = statusText.includes('completed');
                                break;
                            case 'no_baseline':
                                matchesStatus = statusText.includes('no baseline');
                                break;
                            case 'failed':
                                matchesStatus = statusText.includes('failed');
                                break;
                            case 'not_started':
                                matchesStatus = statusText.includes('not started');
                                break;
                        }
                    }
                    
                    return matchesSearch && matchesStatus;
                });
                
                // Reset to first page
                currentPage = 1;
                displayFilteredResults();
            }
            
            // Display filtered results with pagination
            function displayFilteredResults() {
                // Hide all rows first
                originalRows.forEach(row => row.style.display = 'none');
                
                // Calculate pagination
                const totalRows = filteredRows.length;
                const totalPages = Math.ceil(totalRows / rowsPerPage);
                const startIndex = (currentPage - 1) * rowsPerPage;
                const endIndex = Math.min(startIndex + rowsPerPage, totalRows);
                
                // Show rows for current page
                for (let i = startIndex; i < endIndex; i++) {
                    if (filteredRows[i]) {
                        filteredRows[i].style.display = '';
                    }
                }
                
                // Update pagination info
                updatePaginationInfo(startIndex + 1, endIndex, totalRows);
                
                // Show/hide empty state
                if (totalRows === 0) {
                    showNoResultsMessage();
                } else {
                    hideNoResultsMessage();
                }
            }
            
            // Update pagination information
            function updatePaginationInfo(start, end, total) {
                const paginationInfo = document.querySelector('.pagination-info');
                if (paginationInfo) {
                    if (total === 0) {
                        paginationInfo.textContent = 'No pages found matching the current filters';
                    } else {
                        paginationInfo.textContent = `Showing ${start} to ${end} of ${total} pages`;
                    }
                }
            }
            
            // Show no results message
            function showNoResultsMessage() {
                let noResultsRow = document.querySelector('.no-results-row');
                if (!noResultsRow) {
                    noResultsRow = document.createElement('tr');
                    noResultsRow.className = 'no-results-row';
                    noResultsRow.innerHTML = `
                        <td colspan="7" class="text-center py-4">
                            <div class="empty-state">
                                <div class="empty-icon">
                                    <i class="fas fa-search"></i>
                                </div>
                                <h5 class="empty-title">No Pages Found</h5>
                                <p class="empty-description">
                                    No pages match your current filter criteria. Try adjusting your filters.
                                </p>
                            </div>
                        </td>
                    `;
                    tableBody.appendChild(noResultsRow);
                }
                noResultsRow.style.display = '';
            }
            
            // Hide no results message
            function hideNoResultsMessage() {
                const noResultsRow = document.querySelector('.no-results-row');
                if (noResultsRow) {
                    noResultsRow.style.display = 'none';
                }
            }
            
            // Clear all filters
            function clearFilters() {
                pageSearch.value = '';
                statusFilter.value = '';
                perPageFilter.value = '10';
                rowsPerPage = 10;
                currentPage = 1;
                
                // Show all rows
                originalRows.forEach(row => row.style.display = '');
                filteredRows = [...originalRows];
                
                // Reset pagination info
                const paginationInfo = document.querySelector('.pagination-info');
                if (paginationInfo && originalRows.length > 0) {
                    const total = originalRows.length;
                    const end = Math.min(10, total);
                    paginationInfo.textContent = `Showing 1 to ${end} of ${total} pages`;
                }
                
                hideNoResultsMessage();
            }
            
            // Event listeners
            applyFiltersBtn.addEventListener('click', applyFilters);
            clearFiltersBtn.addEventListener('click', clearFilters);
            
            // Real-time search
            pageSearch.addEventListener('input', function() {
                // Debounce search input
                clearTimeout(this.searchTimeout);
                this.searchTimeout = setTimeout(applyFilters, 300);
            });
            
            // Auto-apply filters on dropdown changes
            statusFilter.addEventListener('change', applyFilters);
            perPageFilter.addEventListener('change', applyFilters);
        });

        // Checkbox functionality for page selection
        document.addEventListener('DOMContentLoaded', function() {
            const selectAllCheckbox = document.getElementById('selectAllPages');
            const pageCheckboxes = document.querySelectorAll('.page-checkbox');
            const findDifferenceBtn = document.getElementById('findDifferenceBtn');
            const findDifferenceForm = document.getElementById('findDifferenceForm');

            // Select all functionality
            if (selectAllCheckbox) {
                selectAllCheckbox.addEventListener('change', function() {
                    pageCheckboxes.forEach(checkbox => {
                        checkbox.checked = this.checked;
                    });
                    updateFindDifferenceButton();
                });
            }

            // Individual checkbox change
            pageCheckboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function() {
                    updateSelectAllState();
                    updateFindDifferenceButton();
                });
            });

            // Update select all checkbox state based on individual checkboxes
            function updateSelectAllState() {
                if (!selectAllCheckbox) return;
                
                const checkedBoxes = document.querySelectorAll('.page-checkbox:checked');
                const totalBoxes = pageCheckboxes.length;
                
                if (checkedBoxes.length === 0) {
                    selectAllCheckbox.indeterminate = false;
                    selectAllCheckbox.checked = false;
                } else if (checkedBoxes.length === totalBoxes) {
                    selectAllCheckbox.indeterminate = false;
                    selectAllCheckbox.checked = true;
                } else {
                    selectAllCheckbox.indeterminate = true;
                    selectAllCheckbox.checked = false;
                }
            }

            // Update find difference button text and functionality
            function updateFindDifferenceButton() {
                if (!findDifferenceBtn) return;
                
                const checkedBoxes = document.querySelectorAll('.page-checkbox:checked');
                const selectedCount = checkedBoxes.length;
                
                if (selectedCount === 0) {
                    findDifferenceBtn.innerHTML = '<i class="fas fa-search-plus"></i>Find Difference';
                    findDifferenceBtn.title = 'Find differences for all pages';
                } else {
                    findDifferenceBtn.innerHTML = `<i class="fas fa-search-plus"></i>Find Difference (${selectedCount} selected)`;
                    findDifferenceBtn.title = `Find differences for ${selectedCount} selected pages`;
                }
            }

            // Handle find difference form submission
            if (findDifferenceForm) {
                findDifferenceForm.addEventListener('submit', function(e) {
                    const checkedBoxes = document.querySelectorAll('.page-checkbox:checked');
                    
                    if (checkedBoxes.length === 0) {
                        // No pages selected, proceed with all pages (default behavior)
                        return true;
                    }
                    
                    // Add selected page IDs to the form
                    checkedBoxes.forEach(checkbox => {
                        const hiddenInput = document.createElement('input');
                        hiddenInput.type = 'hidden';
                        hiddenInput.name = 'selected_pages';
                        hiddenInput.value = checkbox.value;
                        this.appendChild(hiddenInput);
                    });
                    
                    return true;
                });
            }

            // Initialize button state
            updateFindDifferenceButton();
        });

        // Add event listeners for main table viewport icons
        document.addEventListener('DOMContentLoaded', function() {
            // Add event listeners for clickable viewport icons in the main table
            document.addEventListener('click', function(e) {
                if (e.target.closest('.viewport-icon-inline.clickable')) {
                    const icon = e.target.closest('.viewport-icon-inline.clickable');
                    
                    // Check if this is a history viewport icon - if so, skip this handler
                    if (icon.closest('#historyAccordion') || icon.closest('#historyModal')) {
                        console.log(' History viewport icon clicked - skipping main table handler');
                        return; // Let the onclick attribute handle it
                    }
                    
                    e.stopPropagation();
                    e.preventDefault();
                    
                    console.log(' Main table viewport icon clicked! Element:', icon);
                    
                    try {
                        const pageId = icon.dataset.pageId;
                        const pageName = icon.dataset.pageName;
                        const pagePath = icon.dataset.pagePath;
                        const viewport = icon.dataset.viewport;
                        const diffPct = icon.dataset.diffPct;
                        const lastCrawled = icon.dataset.lastCrawled;
                        const status = icon.dataset.status;
                        
                        console.log(' Main table viewport icon clicked with data:', {
                            pageId, pageName, pagePath, viewport, diffPct, lastCrawled, status
                        });
                        
                        // Validate required data
                        if (!pageId || !pageName || !pagePath || !viewport) {
                            console.error(' Missing required page data:', {
                                pageId, pageName, pagePath, viewport
                            });
                            showToast('error', 'Missing page information. Cannot open visual diff modal.');
                            return;
                        }
                        
                        // Check status and provide appropriate feedback
                        if (status === 'not_started' || status === 'pending') {
                            showToast('info', 'No screenshots available yet. Please run "Find difference" first.');
                            return;
                        } else if (status === 'failed') {
                            showToast('warning', 'Screenshot capture failed. You can still try to view any available images.');
                        } else if (status === 'no_baseline') {
                            showToast('info', 'No baseline images available. Showing current screenshots only.');
                        }
                        
                        // For main table, we need to get the most recent run ID
                        // We'll use a special value to indicate current/latest run
                        const runId = 'current';
                        
                        // Generate proper page slug for asset resolver
                        let pageSlug = pagePath || '/';
                        
                        // Handle root path
                        if (pageSlug === '/' || pageSlug === '') {
                            pageSlug = 'home';
                        } else {
                            // Remove leading/trailing slashes and convert to slug
                            pageSlug = pageSlug.replace(/^\/+|\/+$/g, '');
                            // Replace slashes with dashes and normalize
                            pageSlug = pageSlug.replace(/\//g, '-').replace(/[^a-z0-9\-]/gi, '-').replace(/-+/g, '-').toLowerCase();
                            // Remove leading/trailing dashes
                            pageSlug = pageSlug.replace(/^-+|-+$/g, '');
                            // If empty after processing, use home
                            if (!pageSlug) {
                                pageSlug = 'home';
                            }
                        }
                        
                        // Generate diff image URL
                        const diffUrl = `/assets/runs/${currentProjectId}/current/${viewport}/${pageSlug}-diff.png`;
                        
                        console.log(' Opening diff image in new tab:', diffUrl);
                        
                        // Open diff image directly in new tab
                        window.open(diffUrl, '_blank');
                        
                    } catch (error) {
                        console.error(' Error handling main table viewport icon click:', error);
                        showToast('error', 'Error opening visual diff modal: ' + error.message);
                    }
                }
            });
        });

        // Jobs History Management
        let currentJobs = [];
        let jobPollingInterval = null;

        // Initialize Jobs History on page load
        document.addEventListener('DOMContentLoaded', function() {
            // Clear any existing polling intervals to prevent multiple instances
            if (jobPollingInterval) {
                console.log('Clearing existing job polling interval on page load');
                clearInterval(jobPollingInterval);
                jobPollingInterval = null;
            }
            
            loadJobsHistory();
            
            // Add event listener for Start Job button with explicit event prevention
            document.getElementById('startJobBtn').addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                console.log(' Start Job button clicked - preventing any form submission');
                startNewJob();
            });
        });

        // Load existing jobs history
        function loadJobsHistory() {
            fetch(`/api/projects/${currentProjectId}/jobs`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        currentJobs = data.jobs || [];
                        updateJobsHistoryTable();
                        
                        // Check if there's an active job and start polling - FIXED: Only poll for truly active jobs, enable button for failed/complete
                        const activeJob = currentJobs.find(job =>
                            job.status === 'Crawling' || job.status === 'pending'
                        );
                        
                        // Check for failed or completed jobs that should enable the button
                        const terminalJob = currentJobs.find(job =>
                            ['Job Failed', 'Crawled', 'ready', 'diff_failed'].includes(job.status)
                        );
                        
                        if (activeJob) {
                            console.log(`Found active job ${activeJob.job_number} with status: ${activeJob.status}. Starting polling.`);
                            disableStartJobButton();
                            startJobStatusPolling(activeJob.job_number);
                        } else if (terminalJob) {
                            console.log(`Found terminal job ${terminalJob.job_number} with status: ${terminalJob.status}. Enabling start button.`);
                            enableStartJobButton();
                            // FIXED: Clear any existing polling when job is in terminal state
                            if (jobPollingInterval) {
                                console.log('Clearing polling interval - job in terminal state');
                                clearInterval(jobPollingInterval);
                                jobPollingInterval = null;
                            }
                        } else {
                            console.log('No active jobs found. Polling will not start.');
                            enableStartJobButton();
                            // FIXED: Clear any existing polling when no active jobs
                            if (jobPollingInterval) {
                                console.log('Clearing polling interval - no active jobs');
                                clearInterval(jobPollingInterval);
                                jobPollingInterval = null;
                            }
                        }
                    } else {
                        console.error('Failed to load jobs history:', data.error);
                        showJobsHistoryEmpty();
                    }
                })
                .catch(error => {
                    console.error('Error loading jobs history:', error);
                    showJobsHistoryEmpty();
                });
        }

        // Start a new crawling job
        function startNewJob() {
            console.log(' Start Job button clicked - calling API endpoint');
            
            const startJobBtn = document.getElementById('startJobBtn');
            
            // Check if there's already a job running
            const runningJob = currentJobs.find(job =>
                job.status === 'Crawling'
            );
            
            if (runningJob) {
                console.log(' Job already running, showing warning');
                showToast('warning', 'A job is already running. Please wait for it to complete before starting a new one.');
                return;
            }
            
            // Disable the start job button
            disableStartJobButton();
            
            console.log(' Making API call to start crawl job');
            
            // Start the actual crawling process
            fetch(`/api/projects/${currentProjectId}/start-crawl-job`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => {
                console.log(' API response received:', response.status, response.statusText);
                return response.json();
            })
            .then(data => {
                console.log(' API response data:', data);
                
                if (data.success) {
                    console.log(' Job started successfully');
                    showToast('success', 'Crawling job started successfully!');
                    
                    // Reload jobs history to get the new job
                    loadJobsHistory();
                    
                    // Start polling for job status
                    if (data.job && data.job.job_number) {
                        startJobStatusPolling(data.job.job_number);
                    }
                } else {
                    console.log(' Job start failed:', data.message);
                    showToast('error', data.message || 'Failed to start crawling job');
                    enableStartJobButton();
                }
            })
            .catch(error => {
                console.error(' Error starting job:', error);
                showToast('error', 'Error starting crawling job: ' + error.message);
                enableStartJobButton();
            });
        }

        // Start polling for job status updates - FIXED: Enhanced termination logic
        function startJobStatusPolling(jobNumber) {
            // Clear any existing polling interval
            if (jobPollingInterval) {
                console.log('Clearing existing job polling interval');
                clearInterval(jobPollingInterval);
                jobPollingInterval = null;
            }
            
            console.log(`Starting job status polling for job ${jobNumber}`);
            
            let pollCount = 0;
            const maxPolls = 600; // Maximum 30 minutes (600 * 3 seconds)
            
            jobPollingInterval = setInterval(() => {
                pollCount++;
                console.log(`Job polling attempt ${pollCount} for job ${jobNumber}`);
                
                // Safety check: Stop polling after max attempts
                if (pollCount >= maxPolls) {
                    console.log(`Maximum polling attempts reached for job ${jobNumber}. Stopping polling.`);
                    clearInterval(jobPollingInterval);
                    jobPollingInterval = null;
                    enableStartJobButton();
                    showToast('warning', 'Job polling stopped due to timeout. Please refresh the page to check current status.');
                    return;
                }
                
                // FIXED: Use the latest job status endpoint instead of specific job number
                fetch(`/api/projects/${currentProjectId}/jobs`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.success && data.jobs && data.jobs.length > 0) {
                            // Get the latest job (first in the array since they're sorted by job_number desc)
                            const latestJob = data.jobs[0];
                            console.log(`Latest job ${latestJob.job_number} status: ${latestJob.status}, duration: ${latestJob.duration}, pages: ${latestJob.pages}`);
                            
                            // Update the jobs array and table
                            currentJobs = data.jobs;
                            updateJobsHistoryTable();
                            
                            // Update main project status
                            updateMainProjectStatus(latestJob.status);
                            
                            // NEW: Update per-page status display if pages_status is available
                            if (data.pages_status && Array.isArray(data.pages_status)) {
                                console.log(`Updating per-page status for ${data.pages_status.length} pages`);
                                updatePerPageStatusDisplay(data.pages_status);
                            }
                            
                            // FIXED: Enhanced completion check with explicit termination for ALL terminal states
                            if (['Crawled', 'Job Failed', 'ready', 'diff_failed'].includes(latestJob.status)) {
                                console.log(`Job ${latestJob.job_number} completed with status: ${latestJob.status}. Stopping polling immediately.`);
                                
                                // Immediately clear the interval
                                clearInterval(jobPollingInterval);
                                jobPollingInterval = null;
                                
                                // Re-enable the start button for ALL terminal states
                                enableStartJobButton();
                                
                                // Show appropriate message based on status
                                if (latestJob.status === 'Crawled') {
                                    showToast('success', `Crawling job completed successfully! Duration: ${latestJob.duration || 'N/A'}, Pages: ${latestJob.pages || 0}`);
                                    // Refresh the page to show updated discovered pages
                                    setTimeout(() => {
                                        location.reload();
                                    }, 2000);
                                } else if (latestJob.status === 'ready') {
                                    showToast('success', `Job completed successfully! All phases finished. Pages: ${latestJob.pages || 0}`);
                                    // Refresh the page to show updated discovered pages
                                    setTimeout(() => {
                                        location.reload();
                                    }, 2000);
                                } else if (latestJob.status === 'Job Failed' || latestJob.status === 'diff_failed') {
                                    showToast('error', `Job failed with status: ${latestJob.status}. You can start a new job now.`);
                                }
                                
                                // Exit the function to prevent further execution
                                return;
                            }
                        } else {
                            console.warn(`Invalid response for jobs:`, data);
                        }
                    })
                    .catch(error => {
                        console.error(`Error polling job status:`, error);
                        
                        // Stop polling on network errors to prevent infinite requests
                        if (error.message.includes('Failed to fetch') ||
                            error.message.includes('NetworkError') ||
                            error.message.includes('HTTP 500') ||
                            error.message.includes('HTTP 404')) {
                            console.log(`Network/Server error detected. Stopping job polling.`);
                            clearInterval(jobPollingInterval);
                            jobPollingInterval = null;
                            enableStartJobButton();
                            showToast('error', 'Job polling stopped due to network error. Please refresh the page to check current status.');
                        }
                    });
            }, 3000); // Poll every 3 seconds
        }

        // Update job from server data
        function updateJobFromServer(serverJob) {
            const job = currentJobs.find(j => j.job_number === serverJob.job_number);
            if (job) {
                // Update job with server data
                Object.assign(job, serverJob);
                updateJobsHistoryTable();
            } else {
                // Add new job if not found
                currentJobs.unshift(serverJob);
                updateJobsHistoryTable();
            }
        }
        
        // Update main project status based on latest job
        function updateMainProjectStatus(status) {
            console.log('Updating main project status:', status);
            
            const startJobBtn = document.getElementById('startJobBtn');
            if (!startJobBtn) return;
            
            // Define terminal states that should enable the start button
            const terminalStates = ['Crawled', 'Job Failed', 'ready', 'diff_failed', 'not_started'];
            const runningStates = ['Crawling', 'finding_difference', 'pending'];
            
            if (runningStates.includes(status)) {
                // Job is running - disable start button
                disableStartJobButton();
            } else if (terminalStates.includes(status)) {
                // Job is in terminal state - enable start button
                enableStartJobButton();
            } else {
                // Unknown status - enable start button as safe default
                enableStartJobButton();
            }
        }

        // Format updated_at timestamp to required format (MMM DD, YYYY, hh:mm AM/PM)
        function formatUpdatedAt(timestamp) {
            if (!timestamp) return '-';
            
            try {
                const date = new Date(timestamp);
                if (isNaN(date.getTime())) return '-';
                
                const options = {
                    month: 'short',
                    day: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true
                };
                
                return date.toLocaleDateString('en-US', options).replace(',', ', ');
            } catch (error) {
                console.error('Error formatting timestamp:', error);
                return '-';
            }
        }

        // Calculate duration between start and end time
        function calculateDuration(startTime, endTime) {
            if (!startTime || !endTime) return '-';
            
            try {
                const start = new Date(startTime);
                const end = new Date(endTime);
                
                if (isNaN(start.getTime()) || isNaN(end.getTime())) return '-';
                
                const diffMs = end - start;
                const diffSecs = Math.floor(diffMs / 1000);
                const diffMins = Math.floor(diffSecs / 60);
                const diffHours = Math.floor(diffMins / 60);
                
                if (diffHours > 0) {
                    return `${diffHours}h ${diffMins % 60}m`;
                } else if (diffMins > 0) {
                    return `${diffMins}m ${diffSecs % 60}s`;
                } else {
                    return `${diffSecs}s`;
                }
            } catch (error) {
                console.error('Error calculating duration:', error);
                return '-';
            }
        }

        // Enable the start job button
        function enableStartJobButton() {
            const startJobBtn = document.getElementById('startJobBtn');
            startJobBtn.disabled = false;
            startJobBtn.innerHTML = '<i class="fas fa-play-circle"></i>Start Job';
        }

        // Disable the start job button
        function disableStartJobButton() {
            const startJobBtn = document.getElementById('startJobBtn');
            startJobBtn.disabled = true;
            startJobBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>Job Running...';
        }

        // Update the jobs history table
        function updateJobsHistoryTable() {
            const tableBody = document.getElementById('jobsHistoryTableBody');
            const emptyState = document.getElementById('jobsHistoryEmpty');
            const table = document.getElementById('jobsHistoryTable');
            
            if (currentJobs.length === 0) {
                showJobsHistoryEmpty();
                return;
            }
            
            // Hide empty state and show table
            emptyState.style.display = 'none';
            table.style.display = 'table';
            
            // Clear existing rows
            tableBody.innerHTML = '';
            
            // Add job rows (sorted by job_number descending - newest first)
            const sortedJobs = [...currentJobs].sort((a, b) => b.job_number - a.job_number);
            sortedJobs.forEach(job => {
                const row = createJobRow(job);
                tableBody.appendChild(row);
            });
        }

        // Create a table row for a job
        function createJobRow(job) {
            const row = document.createElement('tr');
            
            // Normalize status to handle different cases and values
            const status = job.status ? job.status.toLowerCase() : 'unknown';

            // Status badge styling
            let statusBadge = '';
            switch(status) {
                case 'pending':
                    statusBadge = '<span class="status-badge" style="background: rgba(142, 144, 147, 0.1); color: var(--subtle-text);"><i class="fas fa-clock me-1"></i>Pending</span>';
                    break;
                case 'crawling':
                    statusBadge = '<span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);"><i class="fas fa-spider me-1"></i>Crawling</span>';
                    break;
                case 'crawled':
                    statusBadge = '<span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);"><i class="fas fa-check-circle me-1"></i>Crawled</span>';
                    break;
                case 'finding_difference':
                    statusBadge = '<span class="status-badge" style="background: rgba(147, 51, 234, 0.1); color: #9333ea;"><i class="fas fa-search-plus me-1"></i>Finding Difference</span>';
                    break;
                case 'result':
                case 'ready':
                    statusBadge = '<span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);"><i class="fas fa-check-circle me-1"></i>Ready</span>';
                    break;
                case 'job failed':
                case 'diff_failed':
                    statusBadge = '<span class="status-badge" style="background: rgba(239, 68, 68, 0.1); color: var(--danger-color);"><i class="fas fa-exclamation-triangle me-1"></i>Job Failed</span>';
                    break;
                default:
                    statusBadge = `<span class="status-badge secondary">${job.status || 'Unknown'}</span>`;
            }
            
            // View button - enabled for completed or ready statuses
            const isViewEnabled = ['crawled', 'ready', 'result'].includes(status);
            const viewButton = isViewEnabled
                ? `<button type="button" class="btn btn-sm btn-primary" onclick="viewJobResults(${job.job_number})" title="View discovered pages">
                     <i class="fas fa-eye me-1"></i>View
                   </button>`
                : `<button type="button" class="btn btn-sm btn-secondary" disabled title="Job must be completed to view results">
                     <i class="fas fa-eye me-1"></i>View
                   </button>`;
            
            row.innerHTML = `
                <td style="font-family: 'Courier New', monospace; font-weight: 600;">${job.job_number}</td>
                <td>${formatUpdatedAt(job.updated_at)}</td>
                <td>${statusBadge}</td>
                <td>${job.pages || 0}</td>
                <td>${viewButton}</td>
            `;
            
            return row;
        }

        // FIXED: View job results - now uses jobrun resolver and run-centric history endpoint
        function viewJobResults(jobNumber) {
            console.log(` View job results clicked for job #${jobNumber} - using run-centric approach`);
            
            // Show loading state
            showToast('info', `Resolving Job #${jobNumber} to run data...`);
            
            // Step 1: Resolve job_id to run_id using the new resolver endpoint
            fetch(`/api/projects/${currentProjectId}/jobs/${jobNumber}/resolve`, {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                credentials: 'include'
            })
                .then(response => {
                    return response.json().then(data => {
                        if (!response.ok) {
                            const errorMessage = data.error || data.message || `HTTP ${response.status}: ${response.statusText}`;
                            throw new Error(errorMessage);
                        }
                        return data;
                    });
                })
                .then(resolverData => {
                    if (resolverData.success && resolverData.run_id) {
                        console.log(` Job #${jobNumber} resolved to run_id: ${resolverData.run_id}`);
                        
                        // Update loading message
                        showToast('info', `Loading history for run ${resolverData.run_id}...`);
                        
                        // Step 2: Use the run-centric history endpoint to get pages
                        return fetch(`/api/history/project/${currentProjectId}/run/${resolverData.run_id}/pages`, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-Requested-With': 'XMLHttpRequest'
                            },
                            credentials: 'include'
                        })
                        .then(response => {
                            return response.json().then(data => {
                                if (!response.ok) {
                                    const errorMessage = data.error || data.message || `HTTP ${response.status}: ${response.statusText}`;
                                    throw new Error(errorMessage);
                                }
                                return { ...data, resolverData }; // Include resolver data for context
                            });
                        });
                    } else {
                        throw new Error(resolverData.error || 'Failed to resolve job to run_id');
                    }
                })
                .then(historyData => {
                    if (historyData.success && historyData.pages) {
                        console.log(` Got ${historyData.pages.length} pages from run-centric history for job #${jobNumber}`);
                        console.log(` Run ID: ${historyData.resolverData.run_id}, Job status: ${historyData.resolverData.job_status}`);
                        
                        if (historyData.pages.length === 0) {
                            showToast('warning', `Job #${jobNumber} has no pages to display. The run may not have completed successfully.`);
                            return;
                        }
                        
                        // Scroll to the discovered pages section
                        const discoveredPagesSection = document.getElementById('discovered-pages-section');
                        if (discoveredPagesSection) {
                            discoveredPagesSection.scrollIntoView({
                                behavior: 'smooth',
                                block: 'start'
                            });
                            
                            // Highlight the section briefly with enhanced visual feedback
                            discoveredPagesSection.style.boxShadow = '0 0 25px rgba(59, 130, 246, 0.4)';
                            discoveredPagesSection.style.border = '3px solid var(--accent-color)';
                            discoveredPagesSection.style.transform = 'scale(1.01)';
                            discoveredPagesSection.style.transition = 'all 0.3s ease';
                            
                            setTimeout(() => {
                                discoveredPagesSection.style.boxShadow = '';
                                discoveredPagesSection.style.border = '';
                                discoveredPagesSection.style.transform = '';
                                discoveredPagesSection.style.transition = '';
                            }, 3000);
                        }
                        
                        // Replace the Discovered Pages table with run-centric history data
                        replaceDiscoveredPagesWithRunHistory(historyData, jobNumber, historyData.resolverData.run_id);
                        
                        // Show success message with run information
                        const duration = historyData.duration || 'N/A';
                        const jobStatus = historyData.resolverData.job_status || 'unknown';
                        
                        showToast('success', `Showing ${historyData.pages.length} pages from Job #${jobNumber} (Run: ${historyData.resolverData.run_id}, Status: ${jobStatus}, Duration: ${duration}).`);
                        
                    } else {
                        throw new Error(historyData.error || 'No pages found for this run');
                    }
                })
                .catch(error => {
                    console.error(` Error loading run-centric history for job #${jobNumber}:`, error);
                    
                    // Provide more specific error messages based on common scenarios
                    let userMessage = error.message;
                    
                    if (error.message.includes('not found')) {
                        userMessage = `Job #${jobNumber} was not found or has no associated run data.`;
                    } else if (error.message.includes('No run_id found')) {
                        userMessage = `Job #${jobNumber} has no run data available. The job may not have completed successfully.`;
                    } else if (error.message.includes('HTTP 404')) {
                        userMessage = `Job #${jobNumber} or its run data was not found.`;
                    } else if (error.message.includes('HTTP 500')) {
                        userMessage = `Server error while loading Job #${jobNumber}. Please try again.`;
                    }
                    
                    showToast('error', userMessage);
                });
        }
        
        // Replace the discovered pages table with run-centric history data
        function replaceDiscoveredPagesWithRunHistory(historyData, jobNumber, runId) {
            const historyPages = historyData.pages || [];
            const duration = historyData.duration || 'N/A';
            const actualJobNumber = historyData.job_number || jobNumber;
            
            console.log(` Replacing discovered pages table with ${historyPages.length} run-centric history pages, duration: ${duration}, job: ${actualJobNumber}, run: ${runId}`);
            
            // Get the DISCOVERED PAGES table body specifically (not the jobs history table)
            const discoveredPagesSection = document.getElementById('discovered-pages-section');
            if (!discoveredPagesSection) {
                console.error(' Discovered pages section not found');
                return;
            }
            
            const tableBody = discoveredPagesSection.querySelector('.modern-table tbody');
            if (!tableBody) {
                console.error(' Discovered pages table body not found');
                return;
            }
            
            // Store original rows for restoration
            if (!window.originalDiscoveredPages) {
                window.originalDiscoveredPages = Array.from(tableBody.children).map(row => row.cloneNode(true));
                console.log(` Stored ${window.originalDiscoveredPages.length} original rows`);
            }
            
            // Clear current table
            tableBody.innerHTML = '';
            
            // Group pages by path to avoid duplicates across viewports
            const groupedPages = {};
            historyPages.forEach(page => {
                const key = page.path || '/';
                if (!groupedPages[key]) {
                    groupedPages[key] = {
                        id: page.id,
                        page_name: page.page_name,
                        path: page.path,
                        staging_url: page.staging_url,
                        production_url: page.production_url,
                        last_run_at: page.last_run_at,
                        find_diff_status: 'ready', // History pages are completed
                        duration_formatted: duration, // Use duration from API response
                        run_id: runId, // Store the run ID for image URLs
                        viewports: {
                            desktop: { status: 'pending', diff_percentage: null },
                            tablet: { status: 'pending', diff_percentage: null },
                            mobile: { status: 'pending', diff_percentage: null }
                        }
                    };
                }
                
                // Update viewport data
                ['desktop', 'tablet', 'mobile'].forEach(viewport => {
                    const status = page[`diff_status_${viewport}`];
                    const diffPct = page[`diff_mismatch_pct_${viewport}`];
                    
                    if (status) {
                        groupedPages[key].viewports[viewport] = {
                            status: status,
                            diff_percentage: diffPct
                        };
                    }
                });
            });
            
            // Create table rows for grouped pages
            const groupedPagesArray = Object.values(groupedPages);
            groupedPagesArray.forEach(pageData => {
                const row = createRunHistoryPageRow(pageData, duration, actualJobNumber, runId);
                tableBody.appendChild(row);
            });
            
            // Update table header to show it's filtered
            updateTableHeaderForRunHistory(actualJobNumber, groupedPagesArray.length, runId);
            
            console.log(` Created ${groupedPagesArray.length} run-centric history page rows`);
        }
        
        // Create a table row for a run-centric history page
        function createRunHistoryPageRow(pageData, duration, jobNumber, runId) {
            const row = document.createElement('tr');
            row.style.backgroundColor = 'rgba(59, 130, 246, 0.05)'; // Light blue background to indicate run-centric history
            
            // Generate viewport icons with proper click handlers for run-centric history
            const viewportIconsHtml = generateViewportIconsForRunHistory(pageData, jobNumber);
            
            // Format last run date using the job's timestamp
            const lastRunFormatted = pageData.last_run_at ?
                new Date(pageData.last_run_at).toLocaleDateString('en-GB', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                }) : 'Never';
            
            const lastRunTime = pageData.last_run_at ?
                new Date(pageData.last_run_at).toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true
                }) : '';
            
            row.innerHTML = `
                <td class="text-center">
                    <input type="checkbox" class="form-check-input" disabled title="Run history record">
                </td>
                <td class="breadcrumb-cell">
                    <div class="page-breadcrumb">
                        <div class="page-title">${pageData.page_name || pageData.path || 'Untitled Page'}</div>
                        <div class="page-path">
                            <code>${pageData.path || '/'}</code>
                        </div>
                    </div>
                </td>
                <td class="url-cell">
                    ${pageData.staging_url ?
                        `<a href="${pageData.staging_url}" target="_blank" class="url-link">
                            ${pageData.staging_url}
                            <i class="fas fa-external-link-alt ms-1"></i>
                        </a>` :
                        '<small class="text-muted">No URL available</small>'
                    }
                </td>
                <td class="url-cell">
                    ${pageData.production_url ?
                        `<a href="${pageData.production_url}" target="_blank" class="url-link">
                            ${pageData.production_url}
                            <i class="fas fa-external-link-alt ms-1"></i>
                        </a>` :
                        '<small class="text-muted">No URL available</small>'
                    }
                </td>
                <td>
                    <span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);">
                        <i class="fas fa-check-circle me-1"></i>READY
                    </span>
                </td>
                <td>
                    ${duration && duration !== 'N/A' ?
                        `<span style="color: var(--primary-text); font-weight: 500; font-family: 'Courier New', monospace;">
                            ${duration}
                        </span>` :
                        '<small style="color: var(--subtle-text);">-</small>'
                    }
                </td>
                <td>
                    <div class="d-flex flex-column">
                        <small style="color: var(--primary-text); font-weight: 500;">${lastRunFormatted}</small>
                        <small style="color: var(--subtle-text); font-size: 0.75rem;">${lastRunTime}</small>
                    </div>
                </td>
                <td>
                    <div class="viewport-icons-inline d-flex gap-1 justify-content-center">
                        ${viewportIconsHtml}
                    </div>
                </td>
            `;
            
            return row;
        }
        
        // Generate viewport icons for run-centric history pages
        function generateViewportIconsForRunHistory(pageData, jobStatus) {
            const viewports = [
                { key: 'desktop', emoji: '<i class="fas fa-desktop"></i>' },
                { key: 'tablet', emoji: '<i class="fas fa-tablet-alt"></i>' },
                { key: 'mobile', emoji: '<i class="fas fa-mobile-alt"></i>' }
            ];
            
            return viewports.map(viewport => {
                const viewportData = pageData.viewports ? pageData.viewports[viewport.key] : null;
                const status = viewportData?.status || pageData[`diff_status_${viewport.key}`] || 'pending';
                const diffPct = viewportData?.diff_percentage || pageData[`diff_mismatch_pct_${viewport.key}`];
                
                let diffText = '';
                let diffColor = 'var(--subtle-text)';
                let titleText = '';
                
                // Handle status based on job status and actual viewport data
                if (status === 'completed' && diffPct !== null && diffPct !== undefined) {
                    diffText = `${Number(diffPct).toFixed(1)}%`;
                    diffColor = diffPct > 5 ? 'var(--danger-color)' : diffPct > 1 ? 'var(--warning-color)' : 'var(--success-color)';
                    titleText = `${viewport.key} - ${Number(diffPct).toFixed(2)}% difference`;
                } else if (status === 'failed') {
                    diffText = '!';
                    diffColor = 'var(--danger-color)';
                    titleText = `${viewport.key} - Failed`;
                } else if (status === 'no_baseline') {
                    diffText = '?';
                    diffColor = 'var(--warning-color)';
                    titleText = `${viewport.key} - No Baseline`;
                } else if (jobStatus === "Crawled" || status === 'captured') {
                    // For crawled jobs, show crawled status
                    diffText = 'CRAWLED';
                    diffColor = 'var(--info-color)';
                    titleText = `${viewport.key} - Crawled (click to view images)`;
                } else if (status === 'ready' || jobStatus === "ready") {
                    diffText = '0.0%';
                    diffColor = 'var(--success-color)';
                    titleText = `${viewport.key} - Ready`;
                } else {
                    // Default status
                    diffText = '-';
                    diffColor = 'var(--subtle-text)';
                    titleText = `${viewport.key} - ${status || 'Unknown'}`;
                }
                
                // History pages should always be clickable to view images
                const isClickable = true;
                const buttonClass = 'viewport-icon-inline clickable';
                const cursor = 'cursor: pointer;';
                
                // Get the current run timestamp for proper image URL generation
                const runTimestamp = pageData.run_id || (currentRunData ? currentRunData.timestamp : 'current');
                
                // Safely escape data attributes
                const safePageId = String(pageData.id || '');
                const safePageName = String(pageData.page_name || pageData.path || 'Untitled Page').replace(/'/g, '&#39;');
                const safePagePath = String(pageData.path || '/').replace(/'/g, '&#39;');
                const safeDiffPct = String(diffPct || 0);
                const safeLastCrawled = String(pageData.last_run_at || '');
                const safeStatus = String(status || 'unknown');
                const safeJobStatus = String(jobStatus || 'unknown');
                const safeRunTimestamp = String(runTimestamp || 'current');
                
                return `
                    <div class="${buttonClass}"
                         style="${cursor} display: flex; flex-direction: column; align-items: center; padding: 0.25rem; min-width: 35px;"
                         title="${titleText}"
                         data-page-id="${safePageId}"
                         data-page-name="${safePageName}"
                         data-page-path="${safePagePath}"
                         data-viewport="${viewport.key}"
                         data-diff-pct="${safeDiffPct}"
                         data-last-crawled="${safeLastCrawled}"
                         data-status="${safeStatus}"
                         data-job-status="${safeJobStatus}"
                         data-run-timestamp="${safeRunTimestamp}"
                         onclick="openRunHistoryImageModal('${safePagePath}', '${viewport.key}', '${safeRunTimestamp}')">
                        <span class="viewport-emoji" style="font-size: 1.1rem; margin-bottom: 0.125rem;">${viewport.emoji}</span>
                        <small style="color: ${diffColor}; font-weight: 600; font-size: 0.625rem;">${diffText}</small>
                    </div>
                `;
            }).join('');
        }
        
        // Update table header to show it's filtered for run-centric history
        function updateTableHeaderForRunHistory(jobNumber, pageCount, runId) {
            // Target the DISCOVERED PAGES section specifically
            const discoveredPagesSection = document.getElementById('discovered-pages-section');
            if (!discoveredPagesSection) {
                console.error(' Discovered pages section not found for header update');
                return;
            }
            
            const tableTitle = discoveredPagesSection.querySelector('.table-card-title');
            if (tableTitle) {
                // Store original title if not already stored
                if (!window.originalTableTitle) {
                    window.originalTableTitle = tableTitle.innerHTML;
                }
                
                tableTitle.innerHTML = `
                    <i class="fas fa-history"></i>Job #${jobNumber} Run History (${runId})
                    <span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);">${pageCount}</span>
                `;
            }
        }
        
        // Open run history image modal for specific job run
        function openRunHistoryImageModal(pagePath, viewport, runTimestamp) {
            console.log(` Opening run history image modal for run ${runTimestamp}, page: ${pagePath}, viewport: ${viewport}`);
            
            // Generate proper page slug for asset resolver
            let pageSlug = pagePath || '/';
            
            // Handle root path
            if (pageSlug === '/' || pageSlug === '') {
                pageSlug = 'home';
            } else {
                // Remove leading/trailing slashes and convert to slug
                pageSlug = pageSlug.replace(/^\/+|\/+$/g, '');
                // Replace slashes with dashes and normalize
                pageSlug = pageSlug.replace(/\//g, '-').replace(/[^a-z0-9\-]/gi, '-').replace(/-+/g, '-').toLowerCase();
                // Remove leading/trailing dashes
                pageSlug = pageSlug.replace(/^-+|-+$/g, '');
                // If empty after processing, use home
                if (!pageSlug) {
                    pageSlug = 'home';
                }
            }
            
            // Use the provided timestamp or fallback to currentRunData
            let timestamp = runTimestamp;
            if (!timestamp || timestamp === 'current') {
                if (currentRunData && currentRunData.timestamp) {
                    timestamp = currentRunData.timestamp;
                } else {
                    console.error(' No valid timestamp available for run history image modal');
                    showToast('error', 'Unable to load images - no valid timestamp available');
                    return;
                }
            }
            
            // Generate image URLs for the specific job run
            const diffUrl = `/assets/runs/${currentProjectId}/${timestamp}/${viewport}/${pageSlug}-diff.png`;
            const productionUrl = `/assets/runs/${currentProjectId}/${timestamp}/${viewport}/${pageSlug}-production.png`;
            const stagingUrl = `/assets/runs/${currentProjectId}/${timestamp}/${viewport}/${pageSlug}-staging.png`;
            
            console.log(' Generated run history image URLs:', {
                pageSlug, timestamp, diffUrl, productionUrl, stagingUrl
            });
            
            // Try to open the diff image first, with fallbacks
            const testImage = new Image();
            testImage.onload = function() {
                console.log(' Diff image loaded successfully, opening in new tab');
                window.open(diffUrl, '_blank');
                showToast('success', `Viewing difference image for ${pagePath} (${viewport})`);
            };
            testImage.onerror = function() {
                console.warn(' Diff image not available, trying staging image');
                // Try staging image as fallback
                const stagingTestImage = new Image();
                stagingTestImage.onload = function() {
                    console.log(' Staging image loaded successfully, opening in new tab');
                    window.open(stagingUrl, '_blank');
                    showToast('info', `Viewing staging image for ${pagePath} (${viewport}) - diff not available`);
                };
                stagingTestImage.onerror = function() {
                    console.warn(' Staging image not available, trying production image');
                    // Try production image as final fallback
                    const productionTestImage = new Image();
                    productionTestImage.onload = function() {
                        console.log(' Production image loaded successfully, opening in new tab');
                        window.open(productionUrl, '_blank');
                        showToast('info', `Viewing production image for ${pagePath} (${viewport}) - diff and staging not available`);
                    };
                    productionTestImage.onerror = function() {
                        console.error(' No images available for this page/viewport combination');
                        showToast('error', `No images available for ${pagePath} (${viewport}). The screenshots may not have been generated yet.`);
                    };
                    productionTestImage.src = productionUrl;
                };
                stagingTestImage.src = stagingUrl;
            };
            testImage.src = diffUrl;
        }
        
        // Replace the discovered pages table with job-specific data using new API format
        function replaceDiscoveredPagesWithJobData(jobData, jobNumber) {
            const jobPages = jobData.pages || [];
            const jobStatus = jobData.job_status || 'Unknown';
            const pageDisplayStatus = jobData.page_display_status || 'unknown';
            const duration = jobData.duration || 'N/A';
            
            console.log(` Replacing discovered pages table with ${jobPages.length} job pages, status: ${jobStatus}, display: ${pageDisplayStatus}, duration: ${duration}`);
            
            // Get the DISCOVERED PAGES table body specifically
            const discoveredPagesSection = document.getElementById('discovered-pages-section');
            if (!discoveredPagesSection) {
                console.error(' Discovered pages section not found');
                return;
            }
            
            const tableBody = discoveredPagesSection.querySelector('.modern-table tbody');
            if (!tableBody) {
                console.error(' Discovered pages table body not found');
                return;
            }
            
            // Store original rows for restoration
            if (!window.originalDiscoveredPages) {
                window.originalDiscoveredPages = Array.from(tableBody.children).map(row => row.cloneNode(true));
                console.log(` Stored ${window.originalDiscoveredPages.length} original rows`);
            }
            
            // Clear current table
            tableBody.innerHTML = '';
            
            // Create table rows for job pages
            jobPages.forEach(pageData => {
                const row = createJobPageRow(pageData, jobStatus, pageDisplayStatus, duration, jobNumber);
                tableBody.appendChild(row);
            });
            
            // Update table header to show it's filtered
            updateTableHeaderForJobData(jobNumber, jobPages.length, jobStatus, pageDisplayStatus);
            
            console.log(` Created ${jobPages.length} job page rows`);
        }
        
        // Replace the discovered pages table with job-specific history
        function replaceDiscoveredPagesWithHistory(historyData, jobNumber) {
            const historyPages = historyData.pages || [];
            const duration = historyData.duration || 'N/A';
            const actualJobNumber = historyData.job_number || jobNumber;
            
            console.log(` Replacing discovered pages table with ${historyPages.length} history pages, duration: ${duration}, job: ${actualJobNumber}`);
            
            // Get the DISCOVERED PAGES table body specifically (not the jobs history table)
            const discoveredPagesSection = document.getElementById('discovered-pages-section');
            if (!discoveredPagesSection) {
                console.error(' Discovered pages section not found');
                return;
            }
            
            const tableBody = discoveredPagesSection.querySelector('.modern-table tbody');
            if (!tableBody) {
                console.error(' Discovered pages table body not found');
                return;
            }
            
            // Store original rows for restoration
            if (!window.originalDiscoveredPages) {
                window.originalDiscoveredPages = Array.from(tableBody.children).map(row => row.cloneNode(true));
                console.log(` Stored ${window.originalDiscoveredPages.length} original rows`);
            }
            
            // Clear current table
            tableBody.innerHTML = '';
            
            // Group pages by path to avoid duplicates across viewports
            const groupedPages = {};
            historyPages.forEach(page => {
                const key = page.path || '/';
                if (!groupedPages[key]) {
                    groupedPages[key] = {
                        id: page.id,
                        page_name: page.page_name,
                        path: page.path,
                        staging_url: page.staging_url,
                        production_url: page.production_url,
                        last_run_at: page.last_run_at,
                        find_diff_status: 'ready', // History pages are completed
                        duration_formatted: duration, // Use duration from API response
                        viewports: {
                            desktop: { status: 'pending', diff_percentage: null },
                            tablet: { status: 'pending', diff_percentage: null },
                            mobile: { status: 'pending', diff_percentage: null }
                        }
                    };
                }
                
                // Update viewport data
                ['desktop', 'tablet', 'mobile'].forEach(viewport => {
                    const status = page[`diff_status_${viewport}`];
                    const diffPct = page[`diff_mismatch_pct_${viewport}`];
                    
                    if (status) {
                        groupedPages[key].viewports[viewport] = {
                            status: status,
                            diff_percentage: diffPct
                        };
                    }
                });
            });
            
            // Create table rows for grouped pages
            const groupedPagesArray = Object.values(groupedPages);
            groupedPagesArray.forEach(pageData => {
                const row = createHistoryPageRow(pageData, duration, actualJobNumber);
                tableBody.appendChild(row);
            });
            
            // Update table header to show it's filtered
            updateTableHeaderForHistory(actualJobNumber, groupedPagesArray.length);
            
            console.log(` Created ${groupedPagesArray.length} history page rows`);
        }
        
        // Create a table row for a job page using new API format
        function createJobPageRow(pageData, jobStatus, pageDisplayStatus, duration, jobNumber) {
            const row = document.createElement('tr');
            row.style.backgroundColor = 'rgba(59, 130, 246, 0.05)'; // Light blue background to indicate job-specific data
            
            // Generate viewport icons based on job status and page display status
            const viewportIconsHtml = generateViewportIconsForJobData(pageData, jobStatus, pageDisplayStatus);
            
            // Format last run date
            const lastRunFormatted = pageData.last_run_at ?
                new Date(pageData.last_run_at).toLocaleDateString('en-GB', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                }) : 'Never';
            
            const lastRunTime = pageData.last_run_at ?
                new Date(pageData.last_run_at).toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true
                }) : '';
            
            // Generate status badge based on page display status
            let statusBadge = '';
            switch(pageDisplayStatus) {
                case 'crawled':
                    statusBadge = `
                        <span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);">
                            <i class="fas fa-check-circle me-1"></i>CRAWLED
                        </span>
                    `;
                    break;
                case 'ready':
                    statusBadge = `
                        <span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);">
                            <i class="fas fa-check-circle me-1"></i>READY
                        </span>
                    `;
                    break;
                case 'failed':
                    statusBadge = `
                        <span class="status-badge" style="background: rgba(239, 68, 68, 0.1); color: var(--danger-color);">
                            <i class="fas fa-times-circle me-1"></i>MIXED STATUS
                        </span>
                    `;
                    break;
                default:
                    statusBadge = `
                        <span class="status-badge secondary">
                            <i class="fas fa-minus-circle me-1"></i>UNKNOWN
                        </span>
                    `;
            }
            
            row.innerHTML = `
                <td class="text-center">
                    <input type="checkbox" class="form-check-input" disabled title="Job history record">
                </td>
                <td class="breadcrumb-cell">
                    <div class="page-breadcrumb">
                        <div class="page-title">${pageData.page_title || pageData.path || 'Untitled Page'}</div>
                        <div class="page-path">
                            <code>${pageData.path || '/'}</code>
                        </div>
                    </div>
                </td>
                <td class="url-cell">
                    ${pageData.staging_url ?
                        `<a href="${pageData.staging_url}" target="_blank" class="url-link">
                            ${pageData.staging_url}
                            <i class="fas fa-external-link-alt ms-1"></i>
                        </a>` :
                        '<small class="text-muted">No URL available</small>'
                    }
                </td>
                <td class="url-cell">
                    ${pageData.production_url ?
                        `<a href="${pageData.production_url}" target="_blank" class="url-link">
                            ${pageData.production_url}
                            <i class="fas fa-external-link-alt ms-1"></i>
                        </a>` :
                        '<small class="text-muted">No URL available</small>'
                    }
                </td>
                <td>
                    ${statusBadge}
                </td>
                <td>
                    ${(pageDisplayStatus === 'crawled') ?
                        '<small style="color: var(--subtle-text);">-</small>' :
                        (duration && duration !== 'N/A' ?
                            `<span style="color: var(--primary-text); font-weight: 500; font-family: 'Courier New', monospace;">
                                ${duration}
                            </span>` :
                            '<small style="color: var(--subtle-text);">-</small>'
                        )
                    }
                </td>
                <td>
                    <div class="d-flex flex-column">
                        <small style="color: var(--primary-text); font-weight: 500;">${lastRunFormatted}</small>
                        <small style="color: var(--subtle-text); font-size: 0.75rem;">${lastRunTime}</small>
                    </div>
                </td>
                <td>
                    ${(pageDisplayStatus === 'crawled') ?
                        '<small style="color: var(--subtle-text);">No results available</small>' :
                        `<div class="viewport-icons-inline d-flex gap-1 justify-content-center">
                            ${viewportIconsHtml}
                        </div>`
                    }
                </td>
            `;
            
            return row;
        }
        
        // Generate viewport icons for job data based on page display status
        function generateViewportIconsForJobData(pageData, jobStatus, pageDisplayStatus) {
            const viewports = [
                { key: 'desktop', emoji: '<i class="fas fa-desktop"></i>' },
                { key: 'tablet', emoji: '<i class="fas fa-tablet-alt"></i>' },
                { key: 'mobile', emoji: '<i class="fas fa-mobile-alt"></i>' }
            ];
            
            return viewports.map(viewport => {
                let diffText = '';
                let diffColor = 'var(--subtle-text)';
                let titleText = '';
                
                // Handle different page display statuses
                if (pageDisplayStatus === 'crawled') {
                    // For crawled jobs, show crawled status
                    diffText = 'CRAWLED';
                    diffColor = 'var(--accent-color)';
                    titleText = `${viewport.key} - Crawled`;
                } else if (pageDisplayStatus === 'ready') {
                    // For ready jobs, show diff results if available
                    const diffPct = pageData[`diff_mismatch_pct_${viewport.key}`];
                    const status = pageData[`diff_status_${viewport.key}`];
                    
                    if (status === 'completed' && diffPct !== null && diffPct !== undefined) {
                        diffText = `${Number(diffPct).toFixed(1)}%`;
                        diffColor = diffPct > 5 ? 'var(--danger-color)' : diffPct > 1 ? 'var(--warning-color)' : 'var(--success-color)';
                        titleText = `${viewport.key} - ${Number(diffPct).toFixed(2)}% difference`;
                    } else if (status === 'failed') {
                        diffText = '!';
                        diffColor = 'var(--danger-color)';
                        titleText = `${viewport.key} - Failed`;
                    } else if (status === 'no_baseline') {
                        diffText = '?';
                        diffColor = 'var(--warning-color)';
                        titleText = `${viewport.key} - No Baseline`;
                    } else {
                        diffText = '0.0%';
                        diffColor = 'var(--success-color)';
                        titleText = `${viewport.key} - Ready`;
                    }
                } else if (pageDisplayStatus === 'failed') {
                    // For failed jobs, show mixed status
                    const status = pageData[`diff_status_${viewport.key}`];
                    const diffPct = pageData[`diff_mismatch_pct_${viewport.key}`];
                    
                    if (status === 'completed' && diffPct !== null && diffPct !== undefined) {
                        diffText = `${Number(diffPct).toFixed(1)}%`;
                        diffColor = diffPct > 5 ? 'var(--danger-color)' : diffPct > 1 ? 'var(--warning-color)' : 'var(--success-color)';
                        titleText = `${viewport.key} - ${Number(diffPct).toFixed(2)}% difference`;
                    } else if (status === 'failed') {
                        diffText = '!';
                        diffColor = 'var(--danger-color)';
                        titleText = `${viewport.key} - Failed`;
                    } else if (status === 'ready') {
                        diffText = 'READY';
                        diffColor = 'var(--success-color)';
                        titleText = `${viewport.key} - Ready`;
                    } else {
                        diffText = '-';
                        diffColor = 'var(--subtle-text)';
                        titleText = `${viewport.key} - Pending`;
                    }
                } else {
                    // Unknown status
                    diffText = '-';
                    diffColor = 'var(--subtle-text)';
                    titleText = `${viewport.key} - Unknown status`;
                }
                
                // Job pages should be clickable to view images
                const isClickable = true;
                const buttonClass = 'viewport-icon-inline clickable';
                const cursor = 'cursor: pointer;';
                
                return `
                    <div class="${buttonClass}"
                         style="${cursor} display: flex; flex-direction: column; align-items: center; padding: 0.25rem; min-width: 35px;"
                         title="${titleText}"
                         data-page-id="${pageData.id || ''}"
                         data-page-name="${pageData.page_title || pageData.path || 'Untitled Page'}"
                         data-page-path="${pageData.path || '/'}"
                         data-viewport="${viewport.key}"
                         data-diff-pct="${pageData[`diff_mismatch_pct_${viewport.key}`] || 0}"
                         data-last-crawled="${pageData.last_run_at || ''}"
                         data-status="${pageData[`diff_status_${viewport.key}`] || 'not_started'}"
                         data-job-status="${jobStatus}"
                         data-page-display-status="${pageDisplayStatus}">
                        <span class="viewport-emoji" style="font-size: 1.1rem; margin-bottom: 0.125rem;">${viewport.emoji}</span>
                        <small style="color: ${diffColor}; font-weight: 600; font-size: 0.625rem;">${diffText}</small>
                    </div>
                `;
            }).join('');
        }
        
        // Update table header to show it's filtered for job data
        function updateTableHeaderForJobData(jobNumber, pageCount, jobStatus, pageDisplayStatus) {
            // Target the DISCOVERED PAGES section specifically
            const discoveredPagesSection = document.getElementById('discovered-pages-section');
            if (!discoveredPagesSection) {
                console.error(' Discovered pages section not found for header update');
                return;
            }
            
            const tableTitle = discoveredPagesSection.querySelector('.table-card-title');
            if (tableTitle) {
                // Store original title if not already stored
                if (!window.originalTableTitle) {
                    window.originalTableTitle = tableTitle.innerHTML;
                }
                
                // Create status description based on page display status
                let statusDescription = '';
                switch(pageDisplayStatus) {
                    case 'crawled':
                        statusDescription = 'Crawled Pages';
                        break;
                    case 'ready':
                        statusDescription = 'Ready Pages';
                        break;
                    case 'failed':
                        statusDescription = 'Mixed Status Pages';
                        break;
                    default:
                        statusDescription = 'Job Pages';
                }
                
                tableTitle.innerHTML = `
                    <i class="fas fa-history"></i>Job #${jobNumber} - ${statusDescription}
                    <span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);">${pageCount}</span>
                `;
            }
        }
        
        // Create a table row for a history page
        function createHistoryPageRow(pageData, duration, jobNumber) {
            const row = document.createElement('tr');
            row.style.backgroundColor = 'rgba(59, 130, 246, 0.05)'; // Light blue background to indicate history
            
            // Generate viewport icons with proper click handlers for history
            const viewportIconsHtml = generateViewportIconsForHistory(pageData, duration);
            
            // Format last run date using the job's timestamp
            const lastRunFormatted = pageData.last_run_at ?
                new Date(pageData.last_run_at).toLocaleDateString('en-GB', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric'
                }) : 'Never';
            
            const lastRunTime = pageData.last_run_at ?
                new Date(pageData.last_run_at).toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true
                }) : '';
            
            // Generate production URL if not provided
            const productionUrl = pageData.production_url ||
                (pageData.path && pageData.path !== '/' ?
                    `{{ project.production_url }}${pageData.path}` :
                    '{{ project.production_url }}');
            
            row.innerHTML = `
                <td class="text-center">
                    <input type="checkbox" class="form-check-input" disabled title="History record">
                </td>
                <td class="breadcrumb-cell">
                    <div class="page-breadcrumb">
                        <div class="page-title">${pageData.page_name || pageData.path || 'Untitled Page'}</div>
                        <div class="page-path">
                            <code>${pageData.path || '/'}</code>
                        </div>
                    </div>
                </td>
                <td class="url-cell">
                    ${pageData.staging_url ?
                        `<a href="${pageData.staging_url}" target="_blank" class="url-link">
                            ${pageData.staging_url}
                            <i class="fas fa-external-link-alt ms-1"></i>
                        </a>` :
                        '<small class="text-muted">No URL available</small>'
                    }
                </td>
                <td class="url-cell">
                    ${productionUrl ?
                        `<a href="${productionUrl}" target="_blank" class="url-link">
                            ${productionUrl}
                            <i class="fas fa-external-link-alt ms-1"></i>
                        </a>` :
                        '<small class="text-muted">No URL available</small>'
                    }
                </td>
                <td>
                    <span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);">
                        <i class="fas fa-check-circle me-1"></i>READY
                    </span>
                </td>
                <td>
                    ${duration && duration !== 'N/A' ?
                        `<span style="color: var(--primary-text); font-weight: 500; font-family: 'Courier New', monospace;">
                            ${duration}
                        </span>` :
                        '<small style="color: var(--subtle-text);">-</small>'
                    }
                </td>
                <td>
                    <div class="d-flex flex-column">
                        <small style="color: var(--primary-text); font-weight: 500;">${lastRunFormatted}</small>
                        <small style="color: var(--subtle-text); font-size: 0.75rem;">${lastRunTime}</small>
                    </div>
                </td>
                <td>
                    <div class="viewport-icons-inline d-flex gap-1 justify-content-center">
                        ${viewportIconsHtml}
                    </div>
                </td>
            `;
            
            return row;
        }
        
        // Generate viewport icons for history pages with job status awareness
        function generateViewportIconsForHistory(pageData, jobStatus) {
            const viewports = [
                { key: 'desktop', emoji: '<i class="fas fa-desktop"></i>' },
                { key: 'tablet', emoji: '<i class="fas fa-tablet-alt"></i>' },
                { key: 'mobile', emoji: '<i class="fas fa-mobile-alt"></i>' }
            ];
            
            return viewports.map(viewport => {
                const viewportData = pageData.viewports[viewport.key];
                const status = viewportData?.status || 'pending';
                const diffPct = viewportData?.diff_percentage;
                
                let diffText = '';
                let diffColor = 'var(--subtle-text)';
                let titleText = '';
                
                // Handle status based on job status
                if (jobStatus === "Crawled") {
                    // For crawled jobs, show crawled status
                    if (pageData.has_screenshots) {
                        diffText = 'CRAWLED';
                        diffColor = 'var(--info-color)';
                        titleText = `${viewport.key} - Crawled (screenshots available)`;
                    } else {
                        diffText = 'CRAWLED';
                        diffColor = 'var(--subtle-text)';
                        titleText = `${viewport.key} - Crawled (no screenshots)`;
                    }
                } else if (jobStatus === "ready") {
                    // For ready jobs, show diff results
                    if (status === 'completed' && diffPct !== null && diffPct !== undefined) {
                        diffText = `${Number(diffPct).toFixed(1)}%`;
                        diffColor = diffPct > 5 ? 'var(--danger-color)' : diffPct > 1 ? 'var(--warning-color)' : 'var(--success-color)';
                        titleText = `${viewport.key} - ${diffPct > 5 ? 'Failed' : diffPct > 1 ? 'Warning' : 'Passed'} (${Number(diffPct).toFixed(2)}% difference)`;
                    } else if (status === 'failed') {
                        diffText = '!';
                        diffColor = 'var(--danger-color)';
                        titleText = `${viewport.key} - Failed`;
                    } else if (status === 'no_baseline') {
                        diffText = '?';
                        diffColor = 'var(--warning-color)';
                        titleText = `${viewport.key} - No Baseline`;
                    } else {
                        diffText = '0.0%';
                        diffColor = 'var(--success-color)';
                        titleText = `${viewport.key} - Ready`;
                    }
                } else {
                    // Unknown job status
                    diffText = '-';
                    diffColor = 'var(--subtle-text)';
                    titleText = `${viewport.key} - Unknown status`;
                }
                
                // History pages should always be clickable to view images
                const isClickable = true;
                const buttonClass = 'viewport-icon-inline clickable';
                const cursor = 'cursor: pointer;';
                
                // Get the current run timestamp for proper image URL generation
                const runTimestamp = currentRunData ? currentRunData.timestamp : 'current';
                
                return `
                    <div class="${buttonClass}"
                         style="${cursor} display: flex; flex-direction: column; align-items: center; padding: 0.25rem; min-width: 35px;"
                         title="${titleText}"
                         data-page-id="${pageData.id || ''}"
                         data-page-name="${pageData.page_name || pageData.path || 'Untitled Page'}"
                         data-page-path="${pageData.path || '/'}"
                         data-viewport="${viewport.key}"
                         data-diff-pct="${diffPct || 0}"
                         data-last-crawled="${pageData.last_run_at || ''}"
                         data-status="${status}"
                         data-job-status="${jobStatus}"
                         data-run-timestamp="${runTimestamp}"
                         onclick="openHistoryImageModal('${pageData.path || '/'}', '${viewport.key}', '${runTimestamp}')">
                        <span class="viewport-emoji" style="font-size: 1.1rem; margin-bottom: 0.125rem;">${viewport.emoji}</span>
                        <small style="color: ${diffColor}; font-weight: 600; font-size: 0.625rem;">${diffText}</small>
                    </div>
                `;
            }).join('');
        }
        
        // Update table header to show it's filtered for history
        function updateTableHeaderForHistory(jobNumber, pageCount) {
            // Target the DISCOVERED PAGES section specifically
            const discoveredPagesSection = document.getElementById('discovered-pages-section');
            if (!discoveredPagesSection) {
                console.error(' Discovered pages section not found for header update');
                return;
            }
            
            const tableTitle = discoveredPagesSection.querySelector('.table-card-title');
            if (tableTitle) {
                // Store original title if not already stored
                if (!window.originalTableTitle) {
                    window.originalTableTitle = tableTitle.innerHTML;
                }
                
                tableTitle.innerHTML = `
                    <i class="fas fa-history"></i>Job #${jobNumber} History
                    <span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);">${pageCount}</span>
                `;
            }
            
            // Note: Removed "Show All Pages" button as requested - history view shows all pages by default
        }
        
        // Open history image modal for specific job
        function openHistoryImageModal(pagePath, viewport, runTimestamp) {
            console.log(` Opening history image modal for run ${runTimestamp}, page: ${pagePath}, viewport: ${viewport}`);
            
            // Generate proper page slug for asset resolver
            let pageSlug = pagePath || '/';
            
            // Handle root path
            if (pageSlug === '/' || pageSlug === '') {
                pageSlug = 'home';
            } else {
                // Remove leading/trailing slashes and convert to slug
                pageSlug = pageSlug.replace(/^\/+|\/+$/g, '');
                // Replace slashes with dashes and normalize
                pageSlug = pageSlug.replace(/\//g, '-').replace(/[^a-z0-9\-]/gi, '-').replace(/-+/g, '-').toLowerCase();
                // Remove leading/trailing dashes
                pageSlug = pageSlug.replace(/^-+|-+$/g, '');
                // If empty after processing, use home
                if (!pageSlug) {
                    pageSlug = 'home';
                }
            }
            
            // Use the provided timestamp or fallback to currentRunData
            let timestamp = runTimestamp;
            if (!timestamp || timestamp === 'current') {
                if (currentRunData && currentRunData.timestamp) {
                    timestamp = currentRunData.timestamp;
                } else {
                    console.error(' No valid timestamp available for history image modal');
                    showToast('error', 'Unable to load images - no valid timestamp available');
                    return;
                }
            }
            
            // Generate image URLs for the specific job
            const diffUrl = `/assets/runs/${currentProjectId}/${timestamp}/${viewport}/${pageSlug}-diff.png`;
            const productionUrl = `/assets/runs/${currentProjectId}/${timestamp}/${viewport}/${pageSlug}-production.png`;
            const stagingUrl = `/assets/runs/${currentProjectId}/${timestamp}/${viewport}/${pageSlug}-staging.png`;
            
            console.log(' Generated history image URLs:', {
                pageSlug, timestamp, diffUrl, productionUrl, stagingUrl
            });
            
            // Try to open the diff image first, with fallbacks
            const testImage = new Image();
            testImage.onload = function() {
                console.log(' Diff image loaded successfully, opening in new tab');
                window.open(diffUrl, '_blank');
                showToast('success', `Viewing difference image for ${pagePath} (${viewport})`);
            };
            testImage.onerror = function() {
                console.warn(' Diff image not available, trying staging image');
                // Try staging image as fallback
                const stagingTestImage = new Image();
                stagingTestImage.onload = function() {
                    console.log(' Staging image loaded successfully, opening in new tab');
                    window.open(stagingUrl, '_blank');
                    showToast('info', `Viewing staging image for ${pagePath} (${viewport}) - diff not available`);
                };
                stagingTestImage.onerror = function() {
                    console.warn(' Staging image not available, trying production image');
                    // Try production image as final fallback
                    const productionTestImage = new Image();
                    productionTestImage.onload = function() {
                        console.log(' Production image loaded successfully, opening in new tab');
                        window.open(productionUrl, '_blank');
                        showToast('info', `Viewing production image for ${pagePath} (${viewport}) - diff and staging not available`);
                    };
                    productionTestImage.onerror = function() {
                        console.error(' No images available for this page/viewport combination');
                        showToast('error', `No images available for ${pagePath} (${viewport}). The screenshots may not have been generated yet.`);
                    };
                    productionTestImage.src = productionUrl;
                };
                stagingTestImage.src = stagingUrl;
            };
            testImage.src = diffUrl;
        }
        
        // Note: restoreOriginalDiscoveredPages function removed as requested
        // History view now shows all pages by default without restore functionality

        // Show empty state for jobs history
        function showJobsHistoryEmpty() {
            const tableBody = document.getElementById('jobsHistoryTableBody');
            const emptyState = document.getElementById('jobsHistoryEmpty');
            const table = document.getElementById('jobsHistoryTable');
            
            table.style.display = 'none';
            emptyState.style.display = 'block';
            tableBody.innerHTML = '';
        }

    </script>

    {% if run_state in ['crawling', 'finding_difference'] %}
    <script>
        // Show progress container for active jobs
        const currentRunState = '{{ run_state }}';
        if (currentRunState === 'crawling' || currentRunState === 'finding_difference') {
            document.getElementById('progressContainer').style.display = 'block';
        }
        
        // FIXED: Enhanced status polling with proper termination and persistence
        let statusPollingInterval = null;
        let statusPollCount = 0;
        const maxStatusPolls = 600; // Maximum 30 minutes (600 * 3 seconds)
        
        // Store active process state in sessionStorage for persistence across page refreshes
        function storeActiveProcessState(state, startTime = null) {
            const processState = {
                state: state,
                startTime: startTime || Date.now(),
                projectId: currentProjectId,
                lastUpdate: Date.now()
            };
            sessionStorage.setItem('activeProcessState', JSON.stringify(processState));
            console.log('Stored active process state:', processState);
        }
        
        function getActiveProcessState() {
            try {
                const stored = sessionStorage.getItem('activeProcessState');
                if (stored) {
                    const state = JSON.parse(stored);
                    // Check if state is still valid (not older than 1 hour)
                    if (Date.now() - state.lastUpdate < 3600000 && state.projectId === currentProjectId) {
                        return state;
                    }
                }
            } catch (error) {
                console.error('Error retrieving active process state:', error);
            }
            return null;
        }
        
        function clearActiveProcessState() {
            sessionStorage.removeItem('activeProcessState');
            console.log('Cleared active process state');
        }
        
        function startStatusPolling() {
            // Clear any existing interval
            if (statusPollingInterval) {
                clearInterval(statusPollingInterval);
                statusPollingInterval = null;
            }
            
            console.log('Starting status polling for active job');
            statusPollCount = 0;
            
            // Store the active state for persistence
            storeActiveProcessState(currentRunState);
            
            statusPollingInterval = setInterval(function() {
                statusPollCount++;
                console.log(`Status polling attempt ${statusPollCount}`);
                
                // Safety check: Stop polling after max attempts
                if (statusPollCount >= maxStatusPolls) {
                    console.log('Maximum status polling attempts reached. Stopping polling.');
                    clearInterval(statusPollingInterval);
                    statusPollingInterval = null;
                    clearActiveProcessState();
                    return;
                }
                
                // Call the existing refreshStatus function
                refreshStatus();
            }, 3000);
        }
        
        function stopStatusPolling() {
            if (statusPollingInterval) {
                console.log('Stopping status polling - job completed');
                clearInterval(statusPollingInterval);
                statusPollingInterval = null;
                clearActiveProcessState();
            }
        }
        
        // Check for existing active process on page load
        document.addEventListener('DOMContentLoaded', function() {
            const storedState = getActiveProcessState();
            if (storedState) {
                console.log('Found stored active process state:', storedState);
                
                // Check if the process is still active by making a status call
                fetch(`/projects/{{ project.id }}/status`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.run_state) {
                            const actualState = typeof data.run_state === 'object' ? data.run_state.state : data.run_state;
                            
                            if (['crawling', 'finding_difference'].includes(actualState)) {
                                console.log('Process is still active, resuming polling');
                                // Update the stored state with current actual state
                                storeActiveProcessState(actualState, storedState.startTime);
                                // Resume polling
                                startStatusPolling();
                            } else {
                                console.log('Process is no longer active, clearing stored state');
                                clearActiveProcessState();
                            }
                        } else {
                            clearActiveProcessState();
                        }
                    })
                    .catch(error => {
                        console.error('Error checking process status on page load:', error);
                        // Clear stored state if we can't verify
                        clearActiveProcessState();
                    });
            } else {
                // No stored state, start polling if current state indicates active process
                if (['crawling', 'finding_difference'].includes(currentRunState)) {
                    startStatusPolling();
                }
            }
        });
        
        // Start polling immediately if not already handled by DOMContentLoaded
        if (document.readyState === 'complete') {
            const storedState = getActiveProcessState();
            if (!storedState && ['crawling', 'finding_difference'].includes(currentRunState)) {
                startStatusPolling();
            }
        }
        
        // Initial status check
        refreshStatus();
        
        // Expose functions globally for other scripts to use
        window.stopStatusPolling = stopStatusPolling;
        window.storeActiveProcessState = storeActiveProcessState;
        window.clearActiveProcessState = clearActiveProcessState;
        
        // Handle page visibility changes to pause/resume polling
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                console.log('Page hidden, maintaining status polling');
                // Keep polling active even when page is hidden
            } else {
                console.log('Page visible, ensuring status polling is active');
                const storedState = getActiveProcessState();
                if (storedState && !statusPollingInterval) {
                    console.log('Resuming status polling after page became visible');
                    startStatusPolling();
                }
            }
        });
        
        // Handle beforeunload to update stored state
        window.addEventListener('beforeunload', function() {
            const storedState = getActiveProcessState();
            if (storedState && statusPollingInterval) {
                // Update the last update time before page unload
                storeActiveProcessState(storedState.state, storedState.startTime);
            }
        });
    </script>
    {% endif %}

    <script>
        // Enhanced real-time status updates for My Projects section
        document.addEventListener('DOMContentLoaded', function() {
            // FIXED: Add global polling control
            let activeJobsPolling = null;
            let pollingStartTime = Date.now();
            const maxPollingDuration = 30 * 60 * 1000; // 30 minutes
            
            function startActiveJobsPolling() {
                // Clear any existing polling
                if (activeJobsPolling) {
                    clearInterval(activeJobsPolling);
                    activeJobsPolling = null;
                }
                
                // Check if there are any active jobs and start polling
                activeJobsPolling = setInterval(function() {
                    // Check if polling has exceeded maximum duration
                    if (Date.now() - pollingStartTime > maxPollingDuration) {
                        console.log('Stopping active jobs polling - maximum duration exceeded');
                        clearInterval(activeJobsPolling);
                        activeJobsPolling = null;
                        return;
                    }
                    
                    // Check for active jobs in the jobs history
                    if (currentJobs && currentJobs.length > 0) {
                        const activeJob = currentJobs.find(job =>
                            job.status === 'Crawling' || job.status === 'pending'
                        );
                        
                        if (activeJob) {
                            // Update the main project status display
                            updateMainProjectStatus('crawling');
                        } else {
                            // No active jobs - stop polling
                            console.log('No active jobs found - stopping active jobs polling');
                            clearInterval(activeJobsPolling);
                            activeJobsPolling = null;
                            
                            // Check if we have completed jobs
                            const completedJob = currentJobs.find(job => job.status === 'Crawled');
                            if (completedJob) {
                                updateMainProjectStatus('crawled');
                            }
                        }
                    } else {
                        // No jobs yet, check if we should poll for status
                        fetch(`/projects/{{ project.id }}/status`)
                            .then(response => response.json())
                            .then(data => {
                                if (data.run_state) {
                                    const state = data.run_state.state || data.run_state;
                                    updateMainProjectStatus(state);
                                    
                                    // Stop polling if job is completed
                                    if (['result', 'job_failed', 'crawled'].includes(state)) {
                                        console.log('Job completed - stopping active jobs polling');
                                        clearInterval(activeJobsPolling);
                                        activeJobsPolling = null;
                                    }
                                }
                            })
                            .catch(error => {
                                console.log('Status check failed:', error);
                            });
                    }
                }, 5000); // Check every 5 seconds
            }
            
            // Start polling only if there are active jobs
            if (currentJobs && currentJobs.length > 0) {
                const hasActiveJobs = currentJobs.some(job =>
                    job.status === 'Crawling' || job.status === 'pending'
                );
                if (hasActiveJobs) {
                    startActiveJobsPolling();
                }
            }
            
            // Expose function globally for manual control
            window.stopActiveJobsPolling = function() {
                if (activeJobsPolling) {
                    clearInterval(activeJobsPolling);
                    activeJobsPolling = null;
                    console.log('Active jobs polling stopped manually');
                }
            };
        });
        
        // Function to update the main project status display
        function updateMainProjectStatus(status) {
            const statusElement = document.getElementById('crawlStatus');
            if (!statusElement) return;
            
            let statusHtml = '';
            
            switch(status) {
                case 'not_started':
                    statusHtml = `
                        <span class="status-badge" style="background: rgba(142, 144, 147, 0.1); color: var(--subtle-text);">
                            <i class="fas fa-minus-circle me-1"></i>Not Started
                        </span>
                    `;
                    break;
                case 'crawling':
                case 'Crawling':
                    statusHtml = `
                        <span class="status-badge" style="background: rgba(59, 130, 246, 0.1); color: var(--accent-color);">
                            <i class="fas fa-spider me-1"></i>Crawling
                        </span>
                    `;
                    break;
                case 'crawled':
                case 'Crawled':
                    statusHtml = `
                        <span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);">
                            <i class="fas fa-check-circle me-1"></i>Crawled
                        </span>
                    `;
                    break;
                case 'finding_difference':
                    statusHtml = `
                        <span class="status-badge" style="background: rgba(147, 51, 234, 0.1); color: #9333ea;">
                            <i class="fas fa-search-plus me-1"></i>Finding Differences
                        </span>
                    `;
                    break;
                case 'result':
                    statusHtml = `
                        <span class="status-badge" style="background: rgba(16, 185, 129, 0.1); color: var(--success-color);">
                            <i class="fas fa-chart-line me-1"></i>Results Available
                        </span>
                    `;
                    break;
                case 'job_failed':
                case 'Job Failed':
                    statusHtml = `
                        <span class="status-badge" style="background: rgba(239, 68, 68, 0.1); color: var(--danger-color);">
                            <i class="fas fa-exclamation-triangle me-1"></i>Job Failed
                        </span>
                    `;
                    break;
                default:
                    statusHtml = `
                        <span class="status-badge secondary">
                            <i class="fas fa-minus-circle me-1"></i>Unknown Status
                        </span>
                    `;
            }
            
            statusElement.innerHTML = statusHtml;
            
            // Update last updated time
            const lastUpdatedElement = document.getElementById('lastUpdated');
            if (lastUpdatedElement) {
                lastUpdatedElement.textContent = new Date().toLocaleString();
            }
        }
    </script>

<script>
// Enhanced History Modal Functionality with Authentication Fix
// Global variables for debugging
window.historyDebug = {
    currentProjectId: null,
    currentRunData: null,
    lastApiCall: null,
    lastError: null
};

// Enhanced error handling and logging
function logHistoryDebug(message, data = null) {
    console.log(`[History Debug] ${message}`, data);
    window.historyDebug.lastApiCall = { message, data, timestamp: new Date() };
}

function logHistoryError(message, error = null) {
    console.error(`[History Error] ${message}`, error);
    window.historyDebug.lastError = { message, error, timestamp: new Date() };
    
    // Show user-friendly error message
    showToast('error', `History Error: ${message}`);
}

// Enhanced API call function with proper authentication
async function makeHistoryApiCall(url, options = {}) {
    logHistoryDebug(`Making API call to: ${url}`);
    
    try {
        // Ensure credentials are included for authentication - THIS IS THE KEY FIX
        const defaultOptions = {
            credentials: 'include',
            headers: {
                'Content-Type': 'application/json',
                'X-Requested-With': 'XMLHttpRequest'
            }
        };
        
        const finalOptions = { ...defaultOptions, ...options };
        
        const response = await fetch(url, finalOptions);
        
        logHistoryDebug(`API response status: ${response.status}`);
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        logHistoryDebug(`API response data:`, data);
        
        return data;
    } catch (error) {
        logHistoryError(`API call failed for ${url}`, error);
        throw error;
    }
}

// Override the existing loadHistoryRuns function
async function loadHistoryRunsFixed() {
    const runSelector = document.getElementById('runSelector');
    if (!runSelector) {
        logHistoryError('Run selector element not found');
        return;
    }
    
    runSelector.innerHTML = '<option value="">Loading runs...</option>';
    
    try {
        // Validate project ID
        if (!currentProjectId || isNaN(currentProjectId)) {
            throw new Error(`Invalid project ID: ${currentProjectId}`);
        }
        
        window.historyDebug.currentProjectId = currentProjectId;
        
        // Make API call with enhanced error handling and proper authentication
        const url = `/api/history/project/${currentProjectId}/runs`;
        const historyData = await makeHistoryApiCall(url);
        
        runSelector.innerHTML = '';
        
        if (historyData.success && historyData.runs && historyData.runs.length > 0) {
            // Add default option
            runSelector.innerHTML = '<option value="">Select a process run...</option>';
            
            // Add runs in reverse chronological order (newest first)
            historyData.runs.forEach(run => {
                const option = document.createElement('option');
                option.value = run.timestamp;
                option.textContent = `${run.datetime} (${run.page_count} pages)`;
                option.dataset.runData = JSON.stringify({
                    run_id: run.timestamp,
                    formatted_date: run.datetime,
                    pages_count: run.page_count,
                    timestamp: run.timestamp
                });
                runSelector.appendChild(option);
            });
            
            // Auto-select the most recent run
            if (historyData.runs.length > 0) {
                runSelector.value = historyData.runs[0].timestamp;
                await onRunSelectedFixed();
            }
            
            logHistoryDebug(`Successfully loaded ${historyData.runs.length} runs`);
        } else {
            runSelector.innerHTML = '<option value="">No runs available</option>';
            showHistoryEmpty();
            logHistoryDebug('No runs found for project');
        }
    } catch (error) {
        logHistoryError('Failed to load history runs', error);
        runSelector.innerHTML = '<option value="">Error loading runs</option>';
        showHistoryEmpty();
    }
}

// Override the existing onRunSelected function
async function onRunSelectedFixed() {
    const runSelector = document.getElementById('runSelector');
    if (!runSelector) {
        logHistoryError('Run selector not found');
        return;
    }
    
    const selectedOption = runSelector.options[runSelector.selectedIndex];
    
    if (!selectedOption.value) {
        hideHistoryTable();
        return;
    }
    
    try {
        currentRunData = JSON.parse(selectedOption.dataset.runData);
        window.historyDebug.currentRunData = currentRunData;
        
        logHistoryDebug('Run selected:', currentRunData);
        
        // Update run info
        updateRunInfo(currentRunData);
        
        // Load pages for selected run
        await loadHistoryPagesFixed(currentRunData.run_id);
    } catch (error) {
        logHistoryError('Failed to handle run selection', error);
        showHistoryEmpty();
    }
}

// Override the existing loadHistoryPages function
async function loadHistoryPagesFixed(runId, page = 1, perPage = currentPerPage) {
    showHistoryLoading();
    
    try {
        // Validate inputs
        if (!currentProjectId || isNaN(currentProjectId)) {
            throw new Error(`Invalid project ID: ${currentProjectId}`);
        }
        
        if (!runId) {
            throw new Error(`Invalid run ID: ${runId}`);
        }
        
        // Construct URL with all required parameters
        const url = `/api/history/project/${currentProjectId}/run/${runId}/pages?page=${page}&per_page=${perPage}`;
        
        logHistoryDebug(`Loading pages for run ${runId}, page ${page}, perPage ${perPage}`);
        
        const historyData = await makeHistoryApiCall(url);
        
        hideHistoryLoading();
        
        if (historyData.success && historyData.pages) {
            logHistoryDebug(`Received ${historyData.pages.length} page records from API`);
            
            if (historyData.pages.length > 0) {
                // Group pages by path to avoid duplicates across viewports
                const groupedPages = groupPagesForHistory(historyData.pages);
                const groupedPagesArray = Object.values(groupedPages);
                
                logHistoryDebug(`After grouping: ${groupedPagesArray.length} unique pages`);
                
                // Update global pagination state
                currentPage = historyData.pagination.page;
                currentPerPage = historyData.pagination.per_page;
                currentPagination = historyData.pagination;
                
                logHistoryDebug(`Backend pagination:`, currentPagination);
                
                populateHistoryTableWithGroupedPages(groupedPagesArray);
                updatePaginationControls(currentPagination);
                showHistoryTable();
                
                logHistoryDebug(`History pagination complete - showing ${groupedPagesArray.length} pages`);
            } else {
                // No pages on this page
                if (historyData.pagination && historyData.pagination.total > 0 && historyData.pagination.page > 1) {
                    // We're on a page beyond available data, go to last page
                    const lastPage = historyData.pagination.pages;
                    if (lastPage > 0) {
                        logHistoryDebug(`No pages on page ${page}, redirecting to last page ${lastPage}`);
                        await loadHistoryPagesFixed(runId, lastPage, perPage);
                        return;
                    }
                }
                logHistoryDebug('No pages found');
                showHistoryEmpty();
            }
        } else {
            logHistoryError('API returned no pages or error', historyData.error || 'Unknown error');
            showHistoryEmpty();
        }
    } catch (error) {
        logHistoryError('Failed to load pages', error);
        hideHistoryLoading();
        showHistoryEmpty();
    }
}

// Initialize the fixed history functionality
document.addEventListener('DOMContentLoaded', function() {
    // Replace existing event listeners with fixed versions
    setTimeout(function() {
        const historyModal = document.getElementById('historyModal');
        if (historyModal) {
            // Remove existing listeners
            const newHistoryModal = historyModal.cloneNode(true);
            historyModal.parentNode.replaceChild(newHistoryModal, historyModal);
            
            // Add fixed listener
            newHistoryModal.addEventListener('show.bs.modal', async function() {
                logHistoryDebug('History modal opened with authentication fix');
                await loadHistoryRunsFixed();
            });
        }
        
        // Replace run selector listener
        const runSelector = document.getElementById('runSelector');
        if (runSelector) {
            const newRunSelector = runSelector.cloneNode(true);
            runSelector.parentNode.replaceChild(newRunSelector, runSelector);
            newRunSelector.addEventListener('change', onRunSelectedFixed);
        }
        
        logHistoryDebug('Enhanced history functionality with authentication fix initialized');
    }, 1000);
});
</script>

</body>
</html>